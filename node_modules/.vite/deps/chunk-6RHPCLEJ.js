import {
  Fade_default,
  IconButton_default,
  init_Fade,
  init_IconButton,
  init_useMediaQuery
} from "./chunk-TSFXMUPI.js";
import {
  Typography_default,
  init_Typography
} from "./chunk-F32GU6SD.js";
import {
  createSvgIcon,
  init_utils as init_utils3
} from "./chunk-7VHFJSHA.js";
import {
  init_utils as init_utils2,
  useSlotProps
} from "./chunk-U7OTEWRA.js";
import {
  PickersDay,
  init_PickersDay,
  init_useUtils,
  useDefaultDates,
  useLocaleText,
  useLocalizationContext,
  useNow,
  useUtils
} from "./chunk-3HLKYVLR.js";
import {
  CSSTransition_default,
  TransitionGroup_default,
  init_esm
} from "./chunk-IC3YV4R3.js";
import {
  DAY_MARGIN,
  DAY_SIZE,
  DIALOG_WIDTH,
  MAX_CALENDAR_HEIGHT,
  VIEW_HEIGHT,
  init_dimensions
} from "./chunk-WBLBSMSH.js";
import {
  init_styles,
  useTheme
} from "./chunk-ARKR4PLC.js";
import {
  alpha,
  useMediaQuery
} from "./chunk-ATJ2L2QU.js";
import {
  init_RtlProvider,
  useRtl
} from "./chunk-Y2PDEAIT.js";
import {
  styled_default,
  useThemeProps
} from "./chunk-4ILPJN7T.js";
import {
  _objectWithoutPropertiesLoose,
  clsx_default,
  composeClasses,
  generateUtilityClass,
  generateUtilityClasses,
  init_clsx,
  init_composeClasses,
  init_objectWithoutPropertiesLoose,
  init_useControlled,
  init_useEnhancedEffect,
  init_useEventCallback,
  init_utils,
  require_prop_types,
  useControlled,
  useEnhancedEffect_default,
  useEventCallback_default,
  useForkRef,
  useId
} from "./chunk-EQAZIKX6.js";
import {
  require_jsx_runtime
} from "./chunk-PL7FREAV.js";
import {
  _extends,
  init_extends
} from "./chunk-3XPFQB6S.js";
import {
  require_react
} from "./chunk-XLKA4T3M.js";
import {
  __esm,
  __toESM
} from "./chunk-WXXH56N5.js";

// node_modules/@mui/x-date-pickers/internals/utils/views.js
var areViewsEqual, applyDefaultViewProps;
var init_views = __esm({
  "node_modules/@mui/x-date-pickers/internals/utils/views.js"() {
    areViewsEqual = (views, expectedViews) => {
      if (views.length !== expectedViews.length) {
        return false;
      }
      return expectedViews.every((expectedView) => views.includes(expectedView));
    };
    applyDefaultViewProps = ({
      openTo,
      defaultOpenTo,
      views,
      defaultViews
    }) => {
      const viewsWithDefault = views ?? defaultViews;
      let openToWithDefault;
      if (openTo != null) {
        openToWithDefault = openTo;
      } else if (viewsWithDefault.includes(defaultOpenTo)) {
        openToWithDefault = defaultOpenTo;
      } else if (viewsWithDefault.length > 0) {
        openToWithDefault = viewsWithDefault[0];
      } else {
        throw new Error("MUI X: The `views` prop must contain at least one view.");
      }
      return {
        views: viewsWithDefault,
        openTo: openToWithDefault
      };
    };
  }
});

// node_modules/@mui/x-date-pickers/internals/utils/date-utils.js
var mergeDateAndTime, findClosestEnabledDate, replaceInvalidDateByNull, applyDefaultDate, areDatesEqual, getMonthsInYear, getTodayDate, formatMeridiem, dateViews, isDatePickerView, resolveDateFormat, getWeekdays;
var init_date_utils = __esm({
  "node_modules/@mui/x-date-pickers/internals/utils/date-utils.js"() {
    init_views();
    mergeDateAndTime = (utils, dateParam, timeParam) => {
      let mergedDate = dateParam;
      mergedDate = utils.setHours(mergedDate, utils.getHours(timeParam));
      mergedDate = utils.setMinutes(mergedDate, utils.getMinutes(timeParam));
      mergedDate = utils.setSeconds(mergedDate, utils.getSeconds(timeParam));
      return mergedDate;
    };
    findClosestEnabledDate = ({
      date,
      disableFuture,
      disablePast,
      maxDate,
      minDate,
      isDateDisabled,
      utils,
      timezone
    }) => {
      const today = mergeDateAndTime(utils, utils.date(void 0, timezone), date);
      if (disablePast && utils.isBefore(minDate, today)) {
        minDate = today;
      }
      if (disableFuture && utils.isAfter(maxDate, today)) {
        maxDate = today;
      }
      let forward = date;
      let backward = date;
      if (utils.isBefore(date, minDate)) {
        forward = minDate;
        backward = null;
      }
      if (utils.isAfter(date, maxDate)) {
        if (backward) {
          backward = maxDate;
        }
        forward = null;
      }
      while (forward || backward) {
        if (forward && utils.isAfter(forward, maxDate)) {
          forward = null;
        }
        if (backward && utils.isBefore(backward, minDate)) {
          backward = null;
        }
        if (forward) {
          if (!isDateDisabled(forward)) {
            return forward;
          }
          forward = utils.addDays(forward, 1);
        }
        if (backward) {
          if (!isDateDisabled(backward)) {
            return backward;
          }
          backward = utils.addDays(backward, -1);
        }
      }
      return null;
    };
    replaceInvalidDateByNull = (utils, value) => value == null || !utils.isValid(value) ? null : value;
    applyDefaultDate = (utils, value, defaultValue) => {
      if (value == null || !utils.isValid(value)) {
        return defaultValue;
      }
      return value;
    };
    areDatesEqual = (utils, a, b) => {
      if (!utils.isValid(a) && a != null && !utils.isValid(b) && b != null) {
        return true;
      }
      return utils.isEqual(a, b);
    };
    getMonthsInYear = (utils, year) => {
      const firstMonth = utils.startOfYear(year);
      const months = [firstMonth];
      while (months.length < 12) {
        const prevMonth = months[months.length - 1];
        months.push(utils.addMonths(prevMonth, 1));
      }
      return months;
    };
    getTodayDate = (utils, timezone, valueType) => valueType === "date" ? utils.startOfDay(utils.date(void 0, timezone)) : utils.date(void 0, timezone);
    formatMeridiem = (utils, meridiem) => {
      const date = utils.setHours(utils.date(), meridiem === "am" ? 2 : 14);
      return utils.format(date, "meridiem");
    };
    dateViews = ["year", "month", "day"];
    isDatePickerView = (view) => dateViews.includes(view);
    resolveDateFormat = (utils, {
      format,
      views
    }, isInToolbar) => {
      if (format != null) {
        return format;
      }
      const formats = utils.formats;
      if (areViewsEqual(views, ["year"])) {
        return formats.year;
      }
      if (areViewsEqual(views, ["month"])) {
        return formats.month;
      }
      if (areViewsEqual(views, ["day"])) {
        return formats.dayOfMonth;
      }
      if (areViewsEqual(views, ["month", "year"])) {
        return `${formats.month} ${formats.year}`;
      }
      if (areViewsEqual(views, ["day", "month"])) {
        return `${formats.month} ${formats.dayOfMonth}`;
      }
      if (isInToolbar) {
        return /en/.test(utils.getCurrentLocaleCode()) ? formats.normalDateWithWeekday : formats.normalDate;
      }
      return formats.keyboardDate;
    };
    getWeekdays = (utils, date) => {
      const start = utils.startOfWeek(date);
      return [0, 1, 2, 3, 4, 5, 6].map((diff) => utils.addDays(start, diff));
    };
  }
});

// node_modules/@mui/x-date-pickers/internals/utils/validation/validateDate.js
var validateDate;
var init_validateDate = __esm({
  "node_modules/@mui/x-date-pickers/internals/utils/validation/validateDate.js"() {
    init_date_utils();
    validateDate = ({
      props,
      value,
      adapter
    }) => {
      if (value === null) {
        return null;
      }
      const {
        shouldDisableDate,
        shouldDisableMonth,
        shouldDisableYear,
        disablePast,
        disableFuture,
        timezone
      } = props;
      const now = adapter.utils.date(void 0, timezone);
      const minDate = applyDefaultDate(adapter.utils, props.minDate, adapter.defaultDates.minDate);
      const maxDate = applyDefaultDate(adapter.utils, props.maxDate, adapter.defaultDates.maxDate);
      switch (true) {
        case !adapter.utils.isValid(value):
          return "invalidDate";
        case Boolean(shouldDisableDate && shouldDisableDate(value)):
          return "shouldDisableDate";
        case Boolean(shouldDisableMonth && shouldDisableMonth(value)):
          return "shouldDisableMonth";
        case Boolean(shouldDisableYear && shouldDisableYear(value)):
          return "shouldDisableYear";
        case Boolean(disableFuture && adapter.utils.isAfterDay(value, now)):
          return "disableFuture";
        case Boolean(disablePast && adapter.utils.isBeforeDay(value, now)):
          return "disablePast";
        case Boolean(minDate && adapter.utils.isBeforeDay(value, minDate)):
          return "minDate";
        case Boolean(maxDate && adapter.utils.isAfterDay(value, maxDate)):
          return "maxDate";
        default:
          return null;
      }
    };
  }
});

// node_modules/@mui/x-date-pickers/DateCalendar/useIsDateDisabled.js
var React, useIsDateDisabled;
var init_useIsDateDisabled = __esm({
  "node_modules/@mui/x-date-pickers/DateCalendar/useIsDateDisabled.js"() {
    React = __toESM(require_react());
    init_validateDate();
    init_useUtils();
    useIsDateDisabled = ({
      shouldDisableDate,
      shouldDisableMonth,
      shouldDisableYear,
      minDate,
      maxDate,
      disableFuture,
      disablePast,
      timezone
    }) => {
      const adapter = useLocalizationContext();
      return React.useCallback((day) => validateDate({
        adapter,
        value: day,
        props: {
          shouldDisableDate,
          shouldDisableMonth,
          shouldDisableYear,
          minDate,
          maxDate,
          disableFuture,
          disablePast,
          timezone
        }
      }) !== null, [adapter, shouldDisableDate, shouldDisableMonth, shouldDisableYear, minDate, maxDate, disableFuture, disablePast, timezone]);
    };
  }
});

// node_modules/@mui/x-date-pickers/internals/utils/time-utils.js
var timeViews, isTimeView, isInternalTimeView, getMeridiem, convertValueToMeridiem, convertToMeridiem, getSecondsInDay, createIsAfterIgnoreDatePart, resolveTimeFormat;
var init_time_utils = __esm({
  "node_modules/@mui/x-date-pickers/internals/utils/time-utils.js"() {
    init_views();
    timeViews = ["hours", "minutes", "seconds"];
    isTimeView = (view) => timeViews.includes(view);
    isInternalTimeView = (view) => timeViews.includes(view) || view === "meridiem";
    getMeridiem = (date, utils) => {
      if (!date) {
        return null;
      }
      return utils.getHours(date) >= 12 ? "pm" : "am";
    };
    convertValueToMeridiem = (value, meridiem, ampm) => {
      if (ampm) {
        const currentMeridiem = value >= 12 ? "pm" : "am";
        if (currentMeridiem !== meridiem) {
          return meridiem === "am" ? value - 12 : value + 12;
        }
      }
      return value;
    };
    convertToMeridiem = (time, meridiem, ampm, utils) => {
      const newHoursAmount = convertValueToMeridiem(utils.getHours(time), meridiem, ampm);
      return utils.setHours(time, newHoursAmount);
    };
    getSecondsInDay = (date, utils) => {
      return utils.getHours(date) * 3600 + utils.getMinutes(date) * 60 + utils.getSeconds(date);
    };
    createIsAfterIgnoreDatePart = (disableIgnoringDatePartForTimeValidation, utils) => (dateLeft, dateRight) => {
      if (disableIgnoringDatePartForTimeValidation) {
        return utils.isAfter(dateLeft, dateRight);
      }
      return getSecondsInDay(dateLeft, utils) > getSecondsInDay(dateRight, utils);
    };
    resolveTimeFormat = (utils, {
      format,
      views,
      ampm
    }) => {
      if (format != null) {
        return format;
      }
      const formats = utils.formats;
      if (areViewsEqual(views, ["hours"])) {
        return ampm ? `${formats.hours12h} ${formats.meridiem}` : formats.hours24h;
      }
      if (areViewsEqual(views, ["minutes"])) {
        return formats.minutes;
      }
      if (areViewsEqual(views, ["seconds"])) {
        return formats.seconds;
      }
      if (areViewsEqual(views, ["minutes", "seconds"])) {
        return `${formats.minutes}:${formats.seconds}`;
      }
      if (areViewsEqual(views, ["hours", "minutes", "seconds"])) {
        return ampm ? `${formats.hours12h}:${formats.minutes}:${formats.seconds} ${formats.meridiem}` : `${formats.hours24h}:${formats.minutes}:${formats.seconds}`;
      }
      return ampm ? `${formats.hours12h}:${formats.minutes} ${formats.meridiem}` : `${formats.hours24h}:${formats.minutes}`;
    };
  }
});

// node_modules/@mui/x-date-pickers/internals/utils/getDefaultReferenceDate.js
var SECTION_TYPE_GRANULARITY, getSectionTypeGranularity, roundDate, getDefaultReferenceDate;
var init_getDefaultReferenceDate = __esm({
  "node_modules/@mui/x-date-pickers/internals/utils/getDefaultReferenceDate.js"() {
    init_time_utils();
    init_date_utils();
    SECTION_TYPE_GRANULARITY = {
      year: 1,
      month: 2,
      day: 3,
      hours: 4,
      minutes: 5,
      seconds: 6,
      milliseconds: 7
    };
    getSectionTypeGranularity = (sections) => Math.max(...sections.map((section) => SECTION_TYPE_GRANULARITY[section.type] ?? 1));
    roundDate = (utils, granularity, date) => {
      if (granularity === SECTION_TYPE_GRANULARITY.year) {
        return utils.startOfYear(date);
      }
      if (granularity === SECTION_TYPE_GRANULARITY.month) {
        return utils.startOfMonth(date);
      }
      if (granularity === SECTION_TYPE_GRANULARITY.day) {
        return utils.startOfDay(date);
      }
      let roundedDate = date;
      if (granularity < SECTION_TYPE_GRANULARITY.minutes) {
        roundedDate = utils.setMinutes(roundedDate, 0);
      }
      if (granularity < SECTION_TYPE_GRANULARITY.seconds) {
        roundedDate = utils.setSeconds(roundedDate, 0);
      }
      if (granularity < SECTION_TYPE_GRANULARITY.milliseconds) {
        roundedDate = utils.setMilliseconds(roundedDate, 0);
      }
      return roundedDate;
    };
    getDefaultReferenceDate = ({
      props,
      utils,
      granularity,
      timezone,
      getTodayDate: inGetTodayDate
    }) => {
      let referenceDate = inGetTodayDate ? inGetTodayDate() : roundDate(utils, granularity, getTodayDate(utils, timezone));
      if (props.minDate != null && utils.isAfterDay(props.minDate, referenceDate)) {
        referenceDate = roundDate(utils, granularity, props.minDate);
      }
      if (props.maxDate != null && utils.isBeforeDay(props.maxDate, referenceDate)) {
        referenceDate = roundDate(utils, granularity, props.maxDate);
      }
      const isAfter = createIsAfterIgnoreDatePart(props.disableIgnoringDatePartForTimeValidation ?? false, utils);
      if (props.minTime != null && isAfter(props.minTime, referenceDate)) {
        referenceDate = roundDate(utils, granularity, props.disableIgnoringDatePartForTimeValidation ? props.minTime : mergeDateAndTime(utils, referenceDate, props.minTime));
      }
      if (props.maxTime != null && isAfter(referenceDate, props.maxTime)) {
        referenceDate = roundDate(utils, granularity, props.disableIgnoringDatePartForTimeValidation ? props.maxTime : mergeDateAndTime(utils, referenceDate, props.maxTime));
      }
      return referenceDate;
    };
  }
});

// node_modules/@mui/x-date-pickers/internals/hooks/useField/useField.utils.js
var getDateSectionConfigFromFormatToken, getDeltaFromKeyCode, getDaysInWeekStr, getLetterEditingOptions, FORMAT_SECONDS_NO_LEADING_ZEROS, NON_LOCALIZED_DIGITS, getLocalizedDigits, removeLocalizedDigits, applyLocalizedDigits, isStringNumber, cleanLeadingZeros, cleanDigitSectionValue, adjustSectionValue, getSectionVisibleValue, changeSectionValueFormat, isFourDigitYearFormat, doesSectionFormatHaveLeadingZeros, getDateFromDateSections, createDateStrForV7HiddenInputFromSections, createDateStrForV6InputFromSections, getSectionsBoundaries, warnedOnceInvalidSection, validateSections, transferDateSectionValue, reliableSectionModificationOrder, mergeDateIntoReferenceDate, isAndroid, getSectionOrder, parseSelectedSections, getSectionValueText, getSectionValueNow;
var init_useField_utils = __esm({
  "node_modules/@mui/x-date-pickers/internals/hooks/useField/useField.utils.js"() {
    init_date_utils();
    getDateSectionConfigFromFormatToken = (utils, formatToken) => {
      const config = utils.formatTokenMap[formatToken];
      if (config == null) {
        throw new Error([`MUI X: The token "${formatToken}" is not supported by the Date and Time Pickers.`, "Please try using another token or open an issue on https://github.com/mui/mui-x/issues/new/choose if you think it should be supported."].join("\n"));
      }
      if (typeof config === "string") {
        return {
          type: config,
          contentType: config === "meridiem" ? "letter" : "digit",
          maxLength: void 0
        };
      }
      return {
        type: config.sectionType,
        contentType: config.contentType,
        maxLength: config.maxLength
      };
    };
    getDeltaFromKeyCode = (keyCode) => {
      switch (keyCode) {
        case "ArrowUp":
          return 1;
        case "ArrowDown":
          return -1;
        case "PageUp":
          return 5;
        case "PageDown":
          return -5;
        default:
          return 0;
      }
    };
    getDaysInWeekStr = (utils, timezone, format) => {
      const elements = [];
      const now = utils.date(void 0, timezone);
      const startDate = utils.startOfWeek(now);
      const endDate = utils.endOfWeek(now);
      let current = startDate;
      while (utils.isBefore(current, endDate)) {
        elements.push(current);
        current = utils.addDays(current, 1);
      }
      return elements.map((weekDay) => utils.formatByString(weekDay, format));
    };
    getLetterEditingOptions = (utils, timezone, sectionType, format) => {
      switch (sectionType) {
        case "month": {
          return getMonthsInYear(utils, utils.date(void 0, timezone)).map((month) => utils.formatByString(month, format));
        }
        case "weekDay": {
          return getDaysInWeekStr(utils, timezone, format);
        }
        case "meridiem": {
          const now = utils.date(void 0, timezone);
          return [utils.startOfDay(now), utils.endOfDay(now)].map((date) => utils.formatByString(date, format));
        }
        default: {
          return [];
        }
      }
    };
    FORMAT_SECONDS_NO_LEADING_ZEROS = "s";
    NON_LOCALIZED_DIGITS = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
    getLocalizedDigits = (utils) => {
      const today = utils.date(void 0);
      const formattedZero = utils.formatByString(utils.setSeconds(today, 0), FORMAT_SECONDS_NO_LEADING_ZEROS);
      if (formattedZero === "0") {
        return NON_LOCALIZED_DIGITS;
      }
      return Array.from({
        length: 10
      }).map((_, index) => utils.formatByString(utils.setSeconds(today, index), FORMAT_SECONDS_NO_LEADING_ZEROS));
    };
    removeLocalizedDigits = (valueStr, localizedDigits) => {
      if (localizedDigits[0] === "0") {
        return valueStr;
      }
      const digits = [];
      let currentFormattedDigit = "";
      for (let i = 0; i < valueStr.length; i += 1) {
        currentFormattedDigit += valueStr[i];
        const matchingDigitIndex = localizedDigits.indexOf(currentFormattedDigit);
        if (matchingDigitIndex > -1) {
          digits.push(matchingDigitIndex.toString());
          currentFormattedDigit = "";
        }
      }
      return digits.join("");
    };
    applyLocalizedDigits = (valueStr, localizedDigits) => {
      if (localizedDigits[0] === "0") {
        return valueStr;
      }
      return valueStr.split("").map((char) => localizedDigits[Number(char)]).join("");
    };
    isStringNumber = (valueStr, localizedDigits) => {
      const nonLocalizedValueStr = removeLocalizedDigits(valueStr, localizedDigits);
      return !Number.isNaN(Number(nonLocalizedValueStr));
    };
    cleanLeadingZeros = (valueStr, size) => {
      let cleanValueStr = valueStr;
      cleanValueStr = Number(cleanValueStr).toString();
      while (cleanValueStr.length < size) {
        cleanValueStr = `0${cleanValueStr}`;
      }
      return cleanValueStr;
    };
    cleanDigitSectionValue = (utils, value, sectionBoundaries, localizedDigits, section) => {
      if (true) {
        if (section.type !== "day" && section.contentType === "digit-with-letter") {
          throw new Error([`MUI X: The token "${section.format}" is a digit format with letter in it.'
             This type of format is only supported for 'day' sections`].join("\n"));
        }
      }
      if (section.type === "day" && section.contentType === "digit-with-letter") {
        const date = utils.setDate(sectionBoundaries.longestMonth, value);
        return utils.formatByString(date, section.format);
      }
      let valueStr = value.toString();
      if (section.hasLeadingZerosInInput) {
        valueStr = cleanLeadingZeros(valueStr, section.maxLength);
      }
      return applyLocalizedDigits(valueStr, localizedDigits);
    };
    adjustSectionValue = (utils, timezone, section, keyCode, sectionsValueBoundaries, localizedDigits, activeDate, stepsAttributes) => {
      const delta = getDeltaFromKeyCode(keyCode);
      const isStart = keyCode === "Home";
      const isEnd = keyCode === "End";
      const shouldSetAbsolute = section.value === "" || isStart || isEnd;
      const adjustDigitSection = () => {
        const sectionBoundaries = sectionsValueBoundaries[section.type]({
          currentDate: activeDate,
          format: section.format,
          contentType: section.contentType
        });
        const getCleanValue = (value) => cleanDigitSectionValue(utils, value, sectionBoundaries, localizedDigits, section);
        const step = section.type === "minutes" && (stepsAttributes == null ? void 0 : stepsAttributes.minutesStep) ? stepsAttributes.minutesStep : 1;
        const currentSectionValue = parseInt(removeLocalizedDigits(section.value, localizedDigits), 10);
        let newSectionValueNumber = currentSectionValue + delta * step;
        if (shouldSetAbsolute) {
          if (section.type === "year" && !isEnd && !isStart) {
            return utils.formatByString(utils.date(void 0, timezone), section.format);
          }
          if (delta > 0 || isStart) {
            newSectionValueNumber = sectionBoundaries.minimum;
          } else {
            newSectionValueNumber = sectionBoundaries.maximum;
          }
        }
        if (newSectionValueNumber % step !== 0) {
          if (delta < 0 || isStart) {
            newSectionValueNumber += step - (step + newSectionValueNumber) % step;
          }
          if (delta > 0 || isEnd) {
            newSectionValueNumber -= newSectionValueNumber % step;
          }
        }
        if (newSectionValueNumber > sectionBoundaries.maximum) {
          return getCleanValue(sectionBoundaries.minimum + (newSectionValueNumber - sectionBoundaries.maximum - 1) % (sectionBoundaries.maximum - sectionBoundaries.minimum + 1));
        }
        if (newSectionValueNumber < sectionBoundaries.minimum) {
          return getCleanValue(sectionBoundaries.maximum - (sectionBoundaries.minimum - newSectionValueNumber - 1) % (sectionBoundaries.maximum - sectionBoundaries.minimum + 1));
        }
        return getCleanValue(newSectionValueNumber);
      };
      const adjustLetterSection = () => {
        const options = getLetterEditingOptions(utils, timezone, section.type, section.format);
        if (options.length === 0) {
          return section.value;
        }
        if (shouldSetAbsolute) {
          if (delta > 0 || isStart) {
            return options[0];
          }
          return options[options.length - 1];
        }
        const currentOptionIndex = options.indexOf(section.value);
        const newOptionIndex = (currentOptionIndex + delta) % options.length;
        const clampedIndex = (newOptionIndex + options.length) % options.length;
        return options[clampedIndex];
      };
      if (section.contentType === "digit" || section.contentType === "digit-with-letter") {
        return adjustDigitSection();
      }
      return adjustLetterSection();
    };
    getSectionVisibleValue = (section, target, localizedDigits) => {
      let value = section.value || section.placeholder;
      const hasLeadingZeros = target === "non-input" ? section.hasLeadingZerosInFormat : section.hasLeadingZerosInInput;
      if (target === "non-input" && section.hasLeadingZerosInInput && !section.hasLeadingZerosInFormat) {
        value = Number(removeLocalizedDigits(value, localizedDigits)).toString();
      }
      const shouldAddInvisibleSpace = ["input-rtl", "input-ltr"].includes(target) && section.contentType === "digit" && !hasLeadingZeros && value.length === 1;
      if (shouldAddInvisibleSpace) {
        value = `${value}‎`;
      }
      if (target === "input-rtl") {
        value = `⁨${value}⁩`;
      }
      return value;
    };
    changeSectionValueFormat = (utils, valueStr, currentFormat, newFormat) => {
      if (true) {
        if (getDateSectionConfigFromFormatToken(utils, currentFormat).type === "weekDay") {
          throw new Error("changeSectionValueFormat doesn't support week day formats");
        }
      }
      return utils.formatByString(utils.parse(valueStr, currentFormat), newFormat);
    };
    isFourDigitYearFormat = (utils, timezone, format) => utils.formatByString(utils.date(void 0, timezone), format).length === 4;
    doesSectionFormatHaveLeadingZeros = (utils, timezone, contentType, sectionType, format) => {
      if (contentType !== "digit") {
        return false;
      }
      const now = utils.date(void 0, timezone);
      switch (sectionType) {
        case "year": {
          if (isFourDigitYearFormat(utils, timezone, format)) {
            const formatted0001 = utils.formatByString(utils.setYear(now, 1), format);
            return formatted0001 === "0001";
          }
          const formatted2001 = utils.formatByString(utils.setYear(now, 2001), format);
          return formatted2001 === "01";
        }
        case "month": {
          return utils.formatByString(utils.startOfYear(now), format).length > 1;
        }
        case "day": {
          return utils.formatByString(utils.startOfMonth(now), format).length > 1;
        }
        case "weekDay": {
          return utils.formatByString(utils.startOfWeek(now), format).length > 1;
        }
        case "hours": {
          return utils.formatByString(utils.setHours(now, 1), format).length > 1;
        }
        case "minutes": {
          return utils.formatByString(utils.setMinutes(now, 1), format).length > 1;
        }
        case "seconds": {
          return utils.formatByString(utils.setSeconds(now, 1), format).length > 1;
        }
        default: {
          throw new Error("Invalid section type");
        }
      }
    };
    getDateFromDateSections = (utils, sections, localizedDigits) => {
      const shouldSkipWeekDays = sections.some((section) => section.type === "day");
      const sectionFormats = [];
      const sectionValues = [];
      for (let i = 0; i < sections.length; i += 1) {
        const section = sections[i];
        const shouldSkip = shouldSkipWeekDays && section.type === "weekDay";
        if (!shouldSkip) {
          sectionFormats.push(section.format);
          sectionValues.push(getSectionVisibleValue(section, "non-input", localizedDigits));
        }
      }
      const formatWithoutSeparator = sectionFormats.join(" ");
      const dateWithoutSeparatorStr = sectionValues.join(" ");
      return utils.parse(dateWithoutSeparatorStr, formatWithoutSeparator);
    };
    createDateStrForV7HiddenInputFromSections = (sections) => sections.map((section) => {
      return `${section.startSeparator}${section.value || section.placeholder}${section.endSeparator}`;
    }).join("");
    createDateStrForV6InputFromSections = (sections, localizedDigits, isRtl) => {
      const formattedSections = sections.map((section) => {
        const dateValue = getSectionVisibleValue(section, isRtl ? "input-rtl" : "input-ltr", localizedDigits);
        return `${section.startSeparator}${dateValue}${section.endSeparator}`;
      });
      const dateStr = formattedSections.join("");
      if (!isRtl) {
        return dateStr;
      }
      return `⁦${dateStr}⁩`;
    };
    getSectionsBoundaries = (utils, localizedDigits, timezone) => {
      const today = utils.date(void 0, timezone);
      const endOfYear = utils.endOfYear(today);
      const endOfDay = utils.endOfDay(today);
      const {
        maxDaysInMonth,
        longestMonth
      } = getMonthsInYear(utils, today).reduce((acc, month) => {
        const daysInMonth = utils.getDaysInMonth(month);
        if (daysInMonth > acc.maxDaysInMonth) {
          return {
            maxDaysInMonth: daysInMonth,
            longestMonth: month
          };
        }
        return acc;
      }, {
        maxDaysInMonth: 0,
        longestMonth: null
      });
      return {
        year: ({
          format
        }) => ({
          minimum: 0,
          maximum: isFourDigitYearFormat(utils, timezone, format) ? 9999 : 99
        }),
        month: () => ({
          minimum: 1,
          // Assumption: All years have the same amount of months
          maximum: utils.getMonth(endOfYear) + 1
        }),
        day: ({
          currentDate
        }) => ({
          minimum: 1,
          maximum: currentDate != null && utils.isValid(currentDate) ? utils.getDaysInMonth(currentDate) : maxDaysInMonth,
          longestMonth
        }),
        weekDay: ({
          format,
          contentType
        }) => {
          if (contentType === "digit") {
            const daysInWeek = getDaysInWeekStr(utils, timezone, format).map(Number);
            return {
              minimum: Math.min(...daysInWeek),
              maximum: Math.max(...daysInWeek)
            };
          }
          return {
            minimum: 1,
            maximum: 7
          };
        },
        hours: ({
          format
        }) => {
          const lastHourInDay = utils.getHours(endOfDay);
          const hasMeridiem = removeLocalizedDigits(utils.formatByString(utils.endOfDay(today), format), localizedDigits) !== lastHourInDay.toString();
          if (hasMeridiem) {
            return {
              minimum: 1,
              maximum: Number(removeLocalizedDigits(utils.formatByString(utils.startOfDay(today), format), localizedDigits))
            };
          }
          return {
            minimum: 0,
            maximum: lastHourInDay
          };
        },
        minutes: () => ({
          minimum: 0,
          // Assumption: All years have the same amount of minutes
          maximum: utils.getMinutes(endOfDay)
        }),
        seconds: () => ({
          minimum: 0,
          // Assumption: All years have the same amount of seconds
          maximum: utils.getSeconds(endOfDay)
        }),
        meridiem: () => ({
          minimum: 0,
          maximum: 1
        }),
        empty: () => ({
          minimum: 0,
          maximum: 0
        })
      };
    };
    warnedOnceInvalidSection = false;
    validateSections = (sections, valueType) => {
      if (true) {
        if (!warnedOnceInvalidSection) {
          const supportedSections = ["empty"];
          if (["date", "date-time"].includes(valueType)) {
            supportedSections.push("weekDay", "day", "month", "year");
          }
          if (["time", "date-time"].includes(valueType)) {
            supportedSections.push("hours", "minutes", "seconds", "meridiem");
          }
          const invalidSection = sections.find((section) => !supportedSections.includes(section.type));
          if (invalidSection) {
            console.warn(`MUI X: The field component you are using is not compatible with the "${invalidSection.type}" date section.`, `The supported date sections are ["${supportedSections.join('", "')}"]\`.`);
            warnedOnceInvalidSection = true;
          }
        }
      }
    };
    transferDateSectionValue = (utils, timezone, section, dateToTransferFrom, dateToTransferTo) => {
      switch (section.type) {
        case "year": {
          return utils.setYear(dateToTransferTo, utils.getYear(dateToTransferFrom));
        }
        case "month": {
          return utils.setMonth(dateToTransferTo, utils.getMonth(dateToTransferFrom));
        }
        case "weekDay": {
          const formattedDaysInWeek = getDaysInWeekStr(utils, timezone, section.format);
          const dayInWeekStrOfActiveDate = utils.formatByString(dateToTransferFrom, section.format);
          const dayInWeekOfActiveDate = formattedDaysInWeek.indexOf(dayInWeekStrOfActiveDate);
          const dayInWeekOfNewSectionValue = formattedDaysInWeek.indexOf(section.value);
          const diff = dayInWeekOfNewSectionValue - dayInWeekOfActiveDate;
          return utils.addDays(dateToTransferFrom, diff);
        }
        case "day": {
          return utils.setDate(dateToTransferTo, utils.getDate(dateToTransferFrom));
        }
        case "meridiem": {
          const isAM = utils.getHours(dateToTransferFrom) < 12;
          const mergedDateHours = utils.getHours(dateToTransferTo);
          if (isAM && mergedDateHours >= 12) {
            return utils.addHours(dateToTransferTo, -12);
          }
          if (!isAM && mergedDateHours < 12) {
            return utils.addHours(dateToTransferTo, 12);
          }
          return dateToTransferTo;
        }
        case "hours": {
          return utils.setHours(dateToTransferTo, utils.getHours(dateToTransferFrom));
        }
        case "minutes": {
          return utils.setMinutes(dateToTransferTo, utils.getMinutes(dateToTransferFrom));
        }
        case "seconds": {
          return utils.setSeconds(dateToTransferTo, utils.getSeconds(dateToTransferFrom));
        }
        default: {
          return dateToTransferTo;
        }
      }
    };
    reliableSectionModificationOrder = {
      year: 1,
      month: 2,
      day: 3,
      weekDay: 4,
      hours: 5,
      minutes: 6,
      seconds: 7,
      meridiem: 8,
      empty: 9
    };
    mergeDateIntoReferenceDate = (utils, timezone, dateToTransferFrom, sections, referenceDate, shouldLimitToEditedSections) => (
      // cloning sections before sort to avoid mutating it
      [...sections].sort((a, b) => reliableSectionModificationOrder[a.type] - reliableSectionModificationOrder[b.type]).reduce((mergedDate, section) => {
        if (!shouldLimitToEditedSections || section.modified) {
          return transferDateSectionValue(utils, timezone, section, dateToTransferFrom, mergedDate);
        }
        return mergedDate;
      }, referenceDate)
    );
    isAndroid = () => navigator.userAgent.toLowerCase().indexOf("android") > -1;
    getSectionOrder = (sections, shouldApplyRTL) => {
      const neighbors = {};
      if (!shouldApplyRTL) {
        sections.forEach((_, index) => {
          const leftIndex = index === 0 ? null : index - 1;
          const rightIndex = index === sections.length - 1 ? null : index + 1;
          neighbors[index] = {
            leftIndex,
            rightIndex
          };
        });
        return {
          neighbors,
          startIndex: 0,
          endIndex: sections.length - 1
        };
      }
      const rtl2ltr = {};
      const ltr2rtl = {};
      let groupedSectionsStart = 0;
      let groupedSectionsEnd = 0;
      let RTLIndex = sections.length - 1;
      while (RTLIndex >= 0) {
        groupedSectionsEnd = sections.findIndex(
          // eslint-disable-next-line @typescript-eslint/no-loop-func
          (section, index) => {
            var _a;
            return index >= groupedSectionsStart && ((_a = section.endSeparator) == null ? void 0 : _a.includes(" ")) && // Special case where the spaces were not there in the initial input
            section.endSeparator !== " / ";
          }
        );
        if (groupedSectionsEnd === -1) {
          groupedSectionsEnd = sections.length - 1;
        }
        for (let i = groupedSectionsEnd; i >= groupedSectionsStart; i -= 1) {
          ltr2rtl[i] = RTLIndex;
          rtl2ltr[RTLIndex] = i;
          RTLIndex -= 1;
        }
        groupedSectionsStart = groupedSectionsEnd + 1;
      }
      sections.forEach((_, index) => {
        const rtlIndex = ltr2rtl[index];
        const leftIndex = rtlIndex === 0 ? null : rtl2ltr[rtlIndex - 1];
        const rightIndex = rtlIndex === sections.length - 1 ? null : rtl2ltr[rtlIndex + 1];
        neighbors[index] = {
          leftIndex,
          rightIndex
        };
      });
      return {
        neighbors,
        startIndex: rtl2ltr[0],
        endIndex: rtl2ltr[sections.length - 1]
      };
    };
    parseSelectedSections = (selectedSections, sections) => {
      if (selectedSections == null) {
        return null;
      }
      if (selectedSections === "all") {
        return "all";
      }
      if (typeof selectedSections === "string") {
        return sections.findIndex((section) => section.type === selectedSections);
      }
      return selectedSections;
    };
    getSectionValueText = (section, utils) => {
      if (!section.value) {
        return void 0;
      }
      switch (section.type) {
        case "month": {
          if (section.contentType === "digit") {
            return utils.format(utils.setMonth(utils.date(), Number(section.value) - 1), "month");
          }
          const parsedDate = utils.parse(section.value, section.format);
          return parsedDate ? utils.format(parsedDate, "month") : void 0;
        }
        case "day":
          return section.contentType === "digit" ? utils.format(utils.setDate(utils.startOfYear(utils.date()), Number(section.value)), "dayOfMonthFull") : section.value;
        case "weekDay":
          return void 0;
        default:
          return void 0;
      }
    };
    getSectionValueNow = (section, utils) => {
      if (!section.value) {
        return void 0;
      }
      switch (section.type) {
        case "weekDay": {
          if (section.contentType === "letter") {
            return void 0;
          }
          return Number(section.value);
        }
        case "meridiem": {
          const parsedDate = utils.parse(`01:00 ${section.value}`, `${utils.formats.hours12h}:${utils.formats.minutes} ${section.format}`);
          if (parsedDate) {
            return utils.getHours(parsedDate) >= 12 ? 1 : 0;
          }
          return void 0;
        }
        case "day":
          return section.contentType === "digit-with-letter" ? parseInt(section.value, 10) : Number(section.value);
        case "month": {
          if (section.contentType === "digit") {
            return Number(section.value);
          }
          const parsedDate = utils.parse(section.value, section.format);
          return parsedDate ? utils.getMonth(parsedDate) + 1 : void 0;
        }
        default:
          return section.contentType !== "letter" ? Number(section.value) : void 0;
      }
    };
  }
});

// node_modules/@mui/x-date-pickers/internals/utils/valueManagers.js
var _excluded, singleItemValueManager, singleItemFieldValueManager;
var init_valueManagers = __esm({
  "node_modules/@mui/x-date-pickers/internals/utils/valueManagers.js"() {
    init_objectWithoutPropertiesLoose();
    init_date_utils();
    init_getDefaultReferenceDate();
    init_useField_utils();
    _excluded = ["value", "referenceDate"];
    singleItemValueManager = {
      emptyValue: null,
      getTodayValue: getTodayDate,
      getInitialReferenceValue: (_ref) => {
        let {
          value,
          referenceDate
        } = _ref, params = _objectWithoutPropertiesLoose(_ref, _excluded);
        if (value != null && params.utils.isValid(value)) {
          return value;
        }
        if (referenceDate != null) {
          return referenceDate;
        }
        return getDefaultReferenceDate(params);
      },
      cleanValue: replaceInvalidDateByNull,
      areValuesEqual: areDatesEqual,
      isSameError: (a, b) => a === b,
      hasError: (error) => error != null,
      defaultErrorState: null,
      getTimezone: (utils, value) => value == null || !utils.isValid(value) ? null : utils.getTimezone(value),
      setTimezone: (utils, timezone, value) => value == null ? null : utils.setTimezone(value, timezone)
    };
    singleItemFieldValueManager = {
      updateReferenceValue: (utils, value, prevReferenceValue) => value == null || !utils.isValid(value) ? prevReferenceValue : value,
      getSectionsFromValue: (utils, date, prevSections, getSectionsFromDate) => {
        const shouldReUsePrevDateSections = !utils.isValid(date) && !!prevSections;
        if (shouldReUsePrevDateSections) {
          return prevSections;
        }
        return getSectionsFromDate(date);
      },
      getV7HiddenInputValueFromSections: createDateStrForV7HiddenInputFromSections,
      getV6InputValueFromSections: createDateStrForV6InputFromSections,
      getActiveDateManager: (utils, state) => ({
        date: state.value,
        referenceDate: state.referenceValue,
        getSections: (sections) => sections,
        getNewValuesFromNewActiveDate: (newActiveDate) => ({
          value: newActiveDate,
          referenceValue: newActiveDate == null || !utils.isValid(newActiveDate) ? state.referenceValue : newActiveDate
        })
      }),
      parseValueStr: (valueStr, referenceValue, parseDate) => parseDate(valueStr.trim(), referenceValue)
    };
  }
});

// node_modules/@mui/x-date-pickers/DateCalendar/useCalendarState.js
var React2, createCalendarStateReducer, useCalendarState;
var init_useCalendarState = __esm({
  "node_modules/@mui/x-date-pickers/DateCalendar/useCalendarState.js"() {
    init_extends();
    React2 = __toESM(require_react());
    init_useEventCallback();
    init_useIsDateDisabled();
    init_useUtils();
    init_valueManagers();
    init_getDefaultReferenceDate();
    createCalendarStateReducer = (reduceAnimations, disableSwitchToMonthOnDayFocus, utils) => (state, action) => {
      switch (action.type) {
        case "changeMonth":
          return _extends({}, state, {
            slideDirection: action.direction,
            currentMonth: action.newMonth,
            isMonthSwitchingAnimating: !reduceAnimations
          });
        case "finishMonthSwitchingAnimation":
          return _extends({}, state, {
            isMonthSwitchingAnimating: false
          });
        case "changeFocusedDay": {
          if (state.focusedDay != null && action.focusedDay != null && utils.isSameDay(action.focusedDay, state.focusedDay)) {
            return state;
          }
          const needMonthSwitch = action.focusedDay != null && !disableSwitchToMonthOnDayFocus && !utils.isSameMonth(state.currentMonth, action.focusedDay);
          return _extends({}, state, {
            focusedDay: action.focusedDay,
            isMonthSwitchingAnimating: needMonthSwitch && !reduceAnimations && !action.withoutMonthSwitchingAnimation,
            currentMonth: needMonthSwitch ? utils.startOfMonth(action.focusedDay) : state.currentMonth,
            slideDirection: action.focusedDay != null && utils.isAfterDay(action.focusedDay, state.currentMonth) ? "left" : "right"
          });
        }
        default:
          throw new Error("missing support");
      }
    };
    useCalendarState = (params) => {
      const {
        value,
        referenceDate: referenceDateProp,
        disableFuture,
        disablePast,
        disableSwitchToMonthOnDayFocus = false,
        maxDate,
        minDate,
        onMonthChange,
        reduceAnimations,
        shouldDisableDate,
        timezone
      } = params;
      const utils = useUtils();
      const reducerFn = React2.useRef(createCalendarStateReducer(Boolean(reduceAnimations), disableSwitchToMonthOnDayFocus, utils)).current;
      const referenceDate = React2.useMemo(
        () => {
          return singleItemValueManager.getInitialReferenceValue({
            value,
            utils,
            timezone,
            props: params,
            referenceDate: referenceDateProp,
            granularity: SECTION_TYPE_GRANULARITY.day
          });
        },
        []
        // eslint-disable-line react-hooks/exhaustive-deps
      );
      const [calendarState, dispatch] = React2.useReducer(reducerFn, {
        isMonthSwitchingAnimating: false,
        focusedDay: referenceDate,
        currentMonth: utils.startOfMonth(referenceDate),
        slideDirection: "left"
      });
      const handleChangeMonth = React2.useCallback((payload) => {
        dispatch(_extends({
          type: "changeMonth"
        }, payload));
        if (onMonthChange) {
          onMonthChange(payload.newMonth);
        }
      }, [onMonthChange]);
      const changeMonth = React2.useCallback((newDate) => {
        const newDateRequested = newDate;
        if (utils.isSameMonth(newDateRequested, calendarState.currentMonth)) {
          return;
        }
        handleChangeMonth({
          newMonth: utils.startOfMonth(newDateRequested),
          direction: utils.isAfterDay(newDateRequested, calendarState.currentMonth) ? "left" : "right"
        });
      }, [calendarState.currentMonth, handleChangeMonth, utils]);
      const isDateDisabled = useIsDateDisabled({
        shouldDisableDate,
        minDate,
        maxDate,
        disableFuture,
        disablePast,
        timezone
      });
      const onMonthSwitchingAnimationEnd = React2.useCallback(() => {
        dispatch({
          type: "finishMonthSwitchingAnimation"
        });
      }, []);
      const changeFocusedDay = useEventCallback_default((newFocusedDate, withoutMonthSwitchingAnimation) => {
        if (!isDateDisabled(newFocusedDate)) {
          dispatch({
            type: "changeFocusedDay",
            focusedDay: newFocusedDate,
            withoutMonthSwitchingAnimation
          });
        }
      });
      return {
        referenceDate,
        calendarState,
        changeMonth,
        changeFocusedDay,
        isDateDisabled,
        onMonthSwitchingAnimationEnd,
        handleChangeMonth
      };
    };
  }
});

// node_modules/@mui/x-date-pickers/DateCalendar/pickersFadeTransitionGroupClasses.js
var getPickersFadeTransitionGroupUtilityClass, pickersFadeTransitionGroupClasses;
var init_pickersFadeTransitionGroupClasses = __esm({
  "node_modules/@mui/x-date-pickers/DateCalendar/pickersFadeTransitionGroupClasses.js"() {
    init_utils();
    getPickersFadeTransitionGroupUtilityClass = (slot) => generateUtilityClass("MuiPickersFadeTransitionGroup", slot);
    pickersFadeTransitionGroupClasses = generateUtilityClasses("MuiPickersFadeTransitionGroup", ["root"]);
  }
});

// node_modules/@mui/x-date-pickers/DateCalendar/PickersFadeTransitionGroup.js
function PickersFadeTransitionGroup(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersFadeTransitionGroup"
  });
  const {
    children,
    className,
    reduceAnimations,
    transKey
  } = props;
  const classes = useUtilityClasses(props);
  const theme = useTheme();
  if (reduceAnimations) {
    return children;
  }
  return (0, import_jsx_runtime.jsx)(PickersFadeTransitionGroupRoot, {
    className: clsx_default(classes.root, className),
    children: (0, import_jsx_runtime.jsx)(Fade_default, {
      appear: false,
      mountOnEnter: true,
      unmountOnExit: true,
      timeout: {
        appear: theme.transitions.duration.enteringScreen,
        enter: theme.transitions.duration.enteringScreen,
        exit: 0
      },
      children
    }, transKey)
  });
}
var React3, import_jsx_runtime, useUtilityClasses, PickersFadeTransitionGroupRoot;
var init_PickersFadeTransitionGroup = __esm({
  "node_modules/@mui/x-date-pickers/DateCalendar/PickersFadeTransitionGroup.js"() {
    React3 = __toESM(require_react());
    init_clsx();
    init_esm();
    init_Fade();
    init_styles();
    init_composeClasses();
    init_pickersFadeTransitionGroupClasses();
    import_jsx_runtime = __toESM(require_jsx_runtime());
    useUtilityClasses = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"]
      };
      return composeClasses(slots, getPickersFadeTransitionGroupUtilityClass, classes);
    };
    PickersFadeTransitionGroupRoot = styled_default(TransitionGroup_default, {
      name: "MuiPickersFadeTransitionGroup",
      slot: "Root",
      overridesResolver: (_, styles) => styles.root
    })({
      display: "block",
      position: "relative"
    });
  }
});

// node_modules/@mui/x-date-pickers/DateCalendar/pickersSlideTransitionClasses.js
var getPickersSlideTransitionUtilityClass, pickersSlideTransitionClasses;
var init_pickersSlideTransitionClasses = __esm({
  "node_modules/@mui/x-date-pickers/DateCalendar/pickersSlideTransitionClasses.js"() {
    init_utils();
    getPickersSlideTransitionUtilityClass = (slot) => generateUtilityClass("MuiPickersSlideTransition", slot);
    pickersSlideTransitionClasses = generateUtilityClasses("MuiPickersSlideTransition", ["root", "slideEnter-left", "slideEnter-right", "slideEnterActive", "slideExit", "slideExitActiveLeft-left", "slideExitActiveLeft-right"]);
  }
});

// node_modules/@mui/x-date-pickers/DateCalendar/PickersSlideTransition.js
function PickersSlideTransition(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersSlideTransition"
  });
  const {
    children,
    className,
    reduceAnimations,
    transKey
    // extracting `classes` from `other`
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded2);
  const classes = useUtilityClasses2(props);
  const theme = useTheme();
  if (reduceAnimations) {
    return (0, import_jsx_runtime2.jsx)("div", {
      className: clsx_default(classes.root, className),
      children
    });
  }
  const transitionClasses = {
    exit: classes.exit,
    enterActive: classes.enterActive,
    enter: classes.enter,
    exitActive: classes.exitActive
  };
  return (0, import_jsx_runtime2.jsx)(PickersSlideTransitionRoot, {
    className: clsx_default(classes.root, className),
    childFactory: (element) => React4.cloneElement(element, {
      classNames: transitionClasses
    }),
    role: "presentation",
    children: (0, import_jsx_runtime2.jsx)(CSSTransition_default, _extends({
      mountOnEnter: true,
      unmountOnExit: true,
      timeout: theme.transitions.duration.complex,
      classNames: transitionClasses
    }, other, {
      children
    }), transKey)
  });
}
var React4, import_jsx_runtime2, _excluded2, useUtilityClasses2, PickersSlideTransitionRoot;
var init_PickersSlideTransition = __esm({
  "node_modules/@mui/x-date-pickers/DateCalendar/PickersSlideTransition.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    React4 = __toESM(require_react());
    init_clsx();
    init_styles();
    init_composeClasses();
    init_esm();
    init_pickersSlideTransitionClasses();
    import_jsx_runtime2 = __toESM(require_jsx_runtime());
    _excluded2 = ["children", "className", "reduceAnimations", "slideDirection", "transKey", "classes"];
    useUtilityClasses2 = (ownerState) => {
      const {
        classes,
        slideDirection
      } = ownerState;
      const slots = {
        root: ["root"],
        exit: ["slideExit"],
        enterActive: ["slideEnterActive"],
        enter: [`slideEnter-${slideDirection}`],
        exitActive: [`slideExitActiveLeft-${slideDirection}`]
      };
      return composeClasses(slots, getPickersSlideTransitionUtilityClass, classes);
    };
    PickersSlideTransitionRoot = styled_default(TransitionGroup_default, {
      name: "MuiPickersSlideTransition",
      slot: "Root",
      overridesResolver: (_, styles) => [styles.root, {
        [`.${pickersSlideTransitionClasses["slideEnter-left"]}`]: styles["slideEnter-left"]
      }, {
        [`.${pickersSlideTransitionClasses["slideEnter-right"]}`]: styles["slideEnter-right"]
      }, {
        [`.${pickersSlideTransitionClasses.slideEnterActive}`]: styles.slideEnterActive
      }, {
        [`.${pickersSlideTransitionClasses.slideExit}`]: styles.slideExit
      }, {
        [`.${pickersSlideTransitionClasses["slideExitActiveLeft-left"]}`]: styles["slideExitActiveLeft-left"]
      }, {
        [`.${pickersSlideTransitionClasses["slideExitActiveLeft-right"]}`]: styles["slideExitActiveLeft-right"]
      }]
    })(({
      theme
    }) => {
      const slideTransition = theme.transitions.create("transform", {
        duration: theme.transitions.duration.complex,
        easing: "cubic-bezier(0.35, 0.8, 0.4, 1)"
      });
      return {
        display: "block",
        position: "relative",
        overflowX: "hidden",
        "& > *": {
          position: "absolute",
          top: 0,
          right: 0,
          left: 0
        },
        [`& .${pickersSlideTransitionClasses["slideEnter-left"]}`]: {
          willChange: "transform",
          transform: "translate(100%)",
          zIndex: 1
        },
        [`& .${pickersSlideTransitionClasses["slideEnter-right"]}`]: {
          willChange: "transform",
          transform: "translate(-100%)",
          zIndex: 1
        },
        [`& .${pickersSlideTransitionClasses.slideEnterActive}`]: {
          transform: "translate(0%)",
          transition: slideTransition
        },
        [`& .${pickersSlideTransitionClasses.slideExit}`]: {
          transform: "translate(0%)"
        },
        [`& .${pickersSlideTransitionClasses["slideExitActiveLeft-left"]}`]: {
          willChange: "transform",
          transform: "translate(-100%)",
          transition: slideTransition,
          zIndex: 0
        },
        [`& .${pickersSlideTransitionClasses["slideExitActiveLeft-right"]}`]: {
          willChange: "transform",
          transform: "translate(100%)",
          transition: slideTransition,
          zIndex: 0
        }
      };
    });
  }
});

// node_modules/@mui/x-date-pickers/DateCalendar/dayCalendarClasses.js
var getDayCalendarUtilityClass, dayCalendarClasses;
var init_dayCalendarClasses = __esm({
  "node_modules/@mui/x-date-pickers/DateCalendar/dayCalendarClasses.js"() {
    init_utils();
    getDayCalendarUtilityClass = (slot) => generateUtilityClass("MuiDayCalendar", slot);
    dayCalendarClasses = generateUtilityClasses("MuiDayCalendar", ["root", "header", "weekDayLabel", "loadingContainer", "slideTransition", "monthContainer", "weekContainer", "weekNumberLabel", "weekNumber"]);
  }
});

// node_modules/@mui/x-date-pickers/DateCalendar/DayCalendar.js
function WrappedDay(_ref) {
  let {
    parentProps,
    day,
    focusableDay,
    selectedDays,
    isDateDisabled,
    currentMonthNumber,
    isViewFocused
  } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded3);
  const {
    disabled,
    disableHighlightToday,
    isMonthSwitchingAnimating,
    showDaysOutsideCurrentMonth,
    slots,
    slotProps,
    timezone
  } = parentProps;
  const utils = useUtils();
  const now = useNow(timezone);
  const isFocusableDay = focusableDay !== null && utils.isSameDay(day, focusableDay);
  const isSelected = selectedDays.some((selectedDay) => utils.isSameDay(selectedDay, day));
  const isToday = utils.isSameDay(day, now);
  const Day = (slots == null ? void 0 : slots.day) ?? PickersDay;
  const _useSlotProps = useSlotProps({
    elementType: Day,
    externalSlotProps: slotProps == null ? void 0 : slotProps.day,
    additionalProps: _extends({
      disableHighlightToday,
      showDaysOutsideCurrentMonth,
      role: "gridcell",
      isAnimating: isMonthSwitchingAnimating,
      // it is used in date range dragging logic by accessing `dataset.timestamp`
      "data-timestamp": utils.toJsDate(day).valueOf()
    }, other),
    ownerState: _extends({}, parentProps, {
      day,
      selected: isSelected
    })
  }), dayProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded22);
  const isDisabled = React5.useMemo(() => disabled || isDateDisabled(day), [disabled, isDateDisabled, day]);
  const outsideCurrentMonth = React5.useMemo(() => utils.getMonth(day) !== currentMonthNumber, [utils, day, currentMonthNumber]);
  const isFirstVisibleCell = React5.useMemo(() => {
    const startOfMonth = utils.startOfMonth(utils.setMonth(day, currentMonthNumber));
    if (!showDaysOutsideCurrentMonth) {
      return utils.isSameDay(day, startOfMonth);
    }
    return utils.isSameDay(day, utils.startOfWeek(startOfMonth));
  }, [currentMonthNumber, day, showDaysOutsideCurrentMonth, utils]);
  const isLastVisibleCell = React5.useMemo(() => {
    const endOfMonth = utils.endOfMonth(utils.setMonth(day, currentMonthNumber));
    if (!showDaysOutsideCurrentMonth) {
      return utils.isSameDay(day, endOfMonth);
    }
    return utils.isSameDay(day, utils.endOfWeek(endOfMonth));
  }, [currentMonthNumber, day, showDaysOutsideCurrentMonth, utils]);
  return (0, import_jsx_runtime3.jsx)(Day, _extends({}, dayProps, {
    day,
    disabled: isDisabled,
    autoFocus: isViewFocused && isFocusableDay,
    today: isToday,
    outsideCurrentMonth,
    isFirstVisibleCell,
    isLastVisibleCell,
    selected: isSelected,
    tabIndex: isFocusableDay ? 0 : -1,
    "aria-selected": isSelected,
    "aria-current": isToday ? "date" : void 0
  }));
}
function DayCalendar(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiDayCalendar"
  });
  const utils = useUtils();
  const {
    onFocusedDayChange,
    className,
    currentMonth,
    selectedDays,
    focusedDay,
    loading,
    onSelectedDaysChange,
    onMonthSwitchingAnimationEnd,
    readOnly,
    reduceAnimations,
    renderLoading = () => (0, import_jsx_runtime3.jsx)("span", {
      children: "..."
    }),
    slideDirection,
    TransitionProps,
    disablePast,
    disableFuture,
    minDate,
    maxDate,
    shouldDisableDate,
    shouldDisableMonth,
    shouldDisableYear,
    dayOfWeekFormatter = (date) => utils.format(date, "weekdayShort").charAt(0).toUpperCase(),
    hasFocus,
    onFocusedViewChange,
    gridLabelId,
    displayWeekNumber,
    fixedWeekNumber,
    autoFocus,
    timezone
  } = props;
  const now = useNow(timezone);
  const classes = useUtilityClasses3(props);
  const isRtl = useRtl();
  const isDateDisabled = useIsDateDisabled({
    shouldDisableDate,
    shouldDisableMonth,
    shouldDisableYear,
    minDate,
    maxDate,
    disablePast,
    disableFuture,
    timezone
  });
  const localeText = useLocaleText();
  const [internalHasFocus, setInternalHasFocus] = useControlled({
    name: "DayCalendar",
    state: "hasFocus",
    controlled: hasFocus,
    default: autoFocus ?? false
  });
  const [internalFocusedDay, setInternalFocusedDay] = React5.useState(() => focusedDay || now);
  const handleDaySelect = useEventCallback_default((day) => {
    if (readOnly) {
      return;
    }
    onSelectedDaysChange(day);
  });
  const focusDay = (day) => {
    if (!isDateDisabled(day)) {
      onFocusedDayChange(day);
      setInternalFocusedDay(day);
      onFocusedViewChange == null ? void 0 : onFocusedViewChange(true);
      setInternalHasFocus(true);
    }
  };
  const handleKeyDown = useEventCallback_default((event, day) => {
    switch (event.key) {
      case "ArrowUp":
        focusDay(utils.addDays(day, -7));
        event.preventDefault();
        break;
      case "ArrowDown":
        focusDay(utils.addDays(day, 7));
        event.preventDefault();
        break;
      case "ArrowLeft": {
        const newFocusedDayDefault = utils.addDays(day, isRtl ? 1 : -1);
        const nextAvailableMonth = utils.addMonths(day, isRtl ? 1 : -1);
        const closestDayToFocus = findClosestEnabledDate({
          utils,
          date: newFocusedDayDefault,
          minDate: isRtl ? newFocusedDayDefault : utils.startOfMonth(nextAvailableMonth),
          maxDate: isRtl ? utils.endOfMonth(nextAvailableMonth) : newFocusedDayDefault,
          isDateDisabled,
          timezone
        });
        focusDay(closestDayToFocus || newFocusedDayDefault);
        event.preventDefault();
        break;
      }
      case "ArrowRight": {
        const newFocusedDayDefault = utils.addDays(day, isRtl ? -1 : 1);
        const nextAvailableMonth = utils.addMonths(day, isRtl ? -1 : 1);
        const closestDayToFocus = findClosestEnabledDate({
          utils,
          date: newFocusedDayDefault,
          minDate: isRtl ? utils.startOfMonth(nextAvailableMonth) : newFocusedDayDefault,
          maxDate: isRtl ? newFocusedDayDefault : utils.endOfMonth(nextAvailableMonth),
          isDateDisabled,
          timezone
        });
        focusDay(closestDayToFocus || newFocusedDayDefault);
        event.preventDefault();
        break;
      }
      case "Home":
        focusDay(utils.startOfWeek(day));
        event.preventDefault();
        break;
      case "End":
        focusDay(utils.endOfWeek(day));
        event.preventDefault();
        break;
      case "PageUp":
        focusDay(utils.addMonths(day, 1));
        event.preventDefault();
        break;
      case "PageDown":
        focusDay(utils.addMonths(day, -1));
        event.preventDefault();
        break;
      default:
        break;
    }
  });
  const handleFocus = useEventCallback_default((event, day) => focusDay(day));
  const handleBlur = useEventCallback_default((event, day) => {
    if (internalHasFocus && utils.isSameDay(internalFocusedDay, day)) {
      onFocusedViewChange == null ? void 0 : onFocusedViewChange(false);
    }
  });
  const currentMonthNumber = utils.getMonth(currentMonth);
  const currentYearNumber = utils.getYear(currentMonth);
  const validSelectedDays = React5.useMemo(() => selectedDays.filter((day) => !!day).map((day) => utils.startOfDay(day)), [utils, selectedDays]);
  const transitionKey = `${currentYearNumber}-${currentMonthNumber}`;
  const slideNodeRef = React5.useMemo(() => React5.createRef(), [transitionKey]);
  const startOfCurrentWeek = utils.startOfWeek(now);
  const focusableDay = React5.useMemo(() => {
    const startOfMonth = utils.startOfMonth(currentMonth);
    const endOfMonth = utils.endOfMonth(currentMonth);
    if (isDateDisabled(internalFocusedDay) || utils.isAfterDay(internalFocusedDay, endOfMonth) || utils.isBeforeDay(internalFocusedDay, startOfMonth)) {
      return findClosestEnabledDate({
        utils,
        date: internalFocusedDay,
        minDate: startOfMonth,
        maxDate: endOfMonth,
        disablePast,
        disableFuture,
        isDateDisabled,
        timezone
      });
    }
    return internalFocusedDay;
  }, [currentMonth, disableFuture, disablePast, internalFocusedDay, isDateDisabled, utils, timezone]);
  const weeksToDisplay = React5.useMemo(() => {
    const currentMonthWithTimezone = utils.setTimezone(currentMonth, timezone);
    const toDisplay = utils.getWeekArray(currentMonthWithTimezone);
    let nextMonth = utils.addMonths(currentMonthWithTimezone, 1);
    while (fixedWeekNumber && toDisplay.length < fixedWeekNumber) {
      const additionalWeeks = utils.getWeekArray(nextMonth);
      const hasCommonWeek = utils.isSameDay(toDisplay[toDisplay.length - 1][0], additionalWeeks[0][0]);
      additionalWeeks.slice(hasCommonWeek ? 1 : 0).forEach((week) => {
        if (toDisplay.length < fixedWeekNumber) {
          toDisplay.push(week);
        }
      });
      nextMonth = utils.addMonths(nextMonth, 1);
    }
    return toDisplay;
  }, [currentMonth, fixedWeekNumber, utils, timezone]);
  return (0, import_jsx_runtime3.jsxs)(PickersCalendarDayRoot, {
    role: "grid",
    "aria-labelledby": gridLabelId,
    className: classes.root,
    children: [(0, import_jsx_runtime3.jsxs)(PickersCalendarDayHeader, {
      role: "row",
      className: classes.header,
      children: [displayWeekNumber && (0, import_jsx_runtime3.jsx)(PickersCalendarWeekNumberLabel, {
        variant: "caption",
        role: "columnheader",
        "aria-label": localeText.calendarWeekNumberHeaderLabel,
        className: classes.weekNumberLabel,
        children: localeText.calendarWeekNumberHeaderText
      }), getWeekdays(utils, now).map((weekday, i) => (0, import_jsx_runtime3.jsx)(PickersCalendarWeekDayLabel, {
        variant: "caption",
        role: "columnheader",
        "aria-label": utils.format(utils.addDays(startOfCurrentWeek, i), "weekday"),
        className: classes.weekDayLabel,
        children: dayOfWeekFormatter(weekday)
      }, i.toString()))]
    }), loading ? (0, import_jsx_runtime3.jsx)(PickersCalendarLoadingContainer, {
      className: classes.loadingContainer,
      children: renderLoading()
    }) : (0, import_jsx_runtime3.jsx)(PickersCalendarSlideTransition, _extends({
      transKey: transitionKey,
      onExited: onMonthSwitchingAnimationEnd,
      reduceAnimations,
      slideDirection,
      className: clsx_default(className, classes.slideTransition)
    }, TransitionProps, {
      nodeRef: slideNodeRef,
      children: (0, import_jsx_runtime3.jsx)(PickersCalendarWeekContainer, {
        ref: slideNodeRef,
        role: "rowgroup",
        className: classes.monthContainer,
        children: weeksToDisplay.map((week, index) => (0, import_jsx_runtime3.jsxs)(PickersCalendarWeek, {
          role: "row",
          className: classes.weekContainer,
          "aria-rowindex": index + 1,
          children: [displayWeekNumber && (0, import_jsx_runtime3.jsx)(PickersCalendarWeekNumber, {
            className: classes.weekNumber,
            role: "rowheader",
            "aria-label": localeText.calendarWeekNumberAriaLabelText(utils.getWeekNumber(week[0])),
            children: localeText.calendarWeekNumberText(utils.getWeekNumber(week[0]))
          }), week.map((day, dayIndex) => (0, import_jsx_runtime3.jsx)(WrappedDay, {
            parentProps: props,
            day,
            selectedDays: validSelectedDays,
            focusableDay,
            onKeyDown: handleKeyDown,
            onFocus: handleFocus,
            onBlur: handleBlur,
            onDaySelect: handleDaySelect,
            isDateDisabled,
            currentMonthNumber,
            isViewFocused: internalHasFocus,
            "aria-colindex": dayIndex + 1
          }, day.toString()))]
        }, `week-${week[0]}`))
      })
    }))]
  });
}
var React5, import_jsx_runtime3, _excluded3, _excluded22, useUtilityClasses3, weeksContainerHeight, PickersCalendarDayRoot, PickersCalendarDayHeader, PickersCalendarWeekDayLabel, PickersCalendarWeekNumberLabel, PickersCalendarWeekNumber, PickersCalendarLoadingContainer, PickersCalendarSlideTransition, PickersCalendarWeekContainer, PickersCalendarWeek;
var init_DayCalendar = __esm({
  "node_modules/@mui/x-date-pickers/DateCalendar/DayCalendar.js"() {
    init_objectWithoutPropertiesLoose();
    init_extends();
    React5 = __toESM(require_react());
    init_useEventCallback();
    init_Typography();
    init_utils2();
    init_RtlProvider();
    init_styles();
    init_utils();
    init_clsx();
    init_PickersDay();
    init_useUtils();
    init_dimensions();
    init_PickersSlideTransition();
    init_useIsDateDisabled();
    init_date_utils();
    init_dayCalendarClasses();
    import_jsx_runtime3 = __toESM(require_jsx_runtime());
    _excluded3 = ["parentProps", "day", "focusableDay", "selectedDays", "isDateDisabled", "currentMonthNumber", "isViewFocused"];
    _excluded22 = ["ownerState"];
    useUtilityClasses3 = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"],
        header: ["header"],
        weekDayLabel: ["weekDayLabel"],
        loadingContainer: ["loadingContainer"],
        slideTransition: ["slideTransition"],
        monthContainer: ["monthContainer"],
        weekContainer: ["weekContainer"],
        weekNumberLabel: ["weekNumberLabel"],
        weekNumber: ["weekNumber"]
      };
      return composeClasses(slots, getDayCalendarUtilityClass, classes);
    };
    weeksContainerHeight = (DAY_SIZE + DAY_MARGIN * 2) * 6;
    PickersCalendarDayRoot = styled_default("div", {
      name: "MuiDayCalendar",
      slot: "Root",
      overridesResolver: (_, styles) => styles.root
    })({});
    PickersCalendarDayHeader = styled_default("div", {
      name: "MuiDayCalendar",
      slot: "Header",
      overridesResolver: (_, styles) => styles.header
    })({
      display: "flex",
      justifyContent: "center",
      alignItems: "center"
    });
    PickersCalendarWeekDayLabel = styled_default(Typography_default, {
      name: "MuiDayCalendar",
      slot: "WeekDayLabel",
      overridesResolver: (_, styles) => styles.weekDayLabel
    })(({
      theme
    }) => ({
      width: 36,
      height: 40,
      margin: "0 2px",
      textAlign: "center",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      color: (theme.vars || theme).palette.text.secondary
    }));
    PickersCalendarWeekNumberLabel = styled_default(Typography_default, {
      name: "MuiDayCalendar",
      slot: "WeekNumberLabel",
      overridesResolver: (_, styles) => styles.weekNumberLabel
    })(({
      theme
    }) => ({
      width: 36,
      height: 40,
      margin: "0 2px",
      textAlign: "center",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      color: theme.palette.text.disabled
    }));
    PickersCalendarWeekNumber = styled_default(Typography_default, {
      name: "MuiDayCalendar",
      slot: "WeekNumber",
      overridesResolver: (_, styles) => styles.weekNumber
    })(({
      theme
    }) => _extends({}, theme.typography.caption, {
      width: DAY_SIZE,
      height: DAY_SIZE,
      padding: 0,
      margin: `0 ${DAY_MARGIN}px`,
      color: theme.palette.text.disabled,
      fontSize: "0.75rem",
      alignItems: "center",
      justifyContent: "center",
      display: "inline-flex"
    }));
    PickersCalendarLoadingContainer = styled_default("div", {
      name: "MuiDayCalendar",
      slot: "LoadingContainer",
      overridesResolver: (_, styles) => styles.loadingContainer
    })({
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      minHeight: weeksContainerHeight
    });
    PickersCalendarSlideTransition = styled_default(PickersSlideTransition, {
      name: "MuiDayCalendar",
      slot: "SlideTransition",
      overridesResolver: (_, styles) => styles.slideTransition
    })({
      minHeight: weeksContainerHeight
    });
    PickersCalendarWeekContainer = styled_default("div", {
      name: "MuiDayCalendar",
      slot: "MonthContainer",
      overridesResolver: (_, styles) => styles.monthContainer
    })({
      overflow: "hidden"
    });
    PickersCalendarWeek = styled_default("div", {
      name: "MuiDayCalendar",
      slot: "WeekContainer",
      overridesResolver: (_, styles) => styles.weekContainer
    })({
      margin: `${DAY_MARGIN}px 0`,
      display: "flex",
      justifyContent: "center"
    });
  }
});

// node_modules/@mui/x-date-pickers/MonthCalendar/pickersMonthClasses.js
function getPickersMonthUtilityClass(slot) {
  return generateUtilityClass("MuiPickersMonth", slot);
}
var pickersMonthClasses;
var init_pickersMonthClasses = __esm({
  "node_modules/@mui/x-date-pickers/MonthCalendar/pickersMonthClasses.js"() {
    init_utils();
    pickersMonthClasses = generateUtilityClasses("MuiPickersMonth", ["root", "monthButton", "disabled", "selected"]);
  }
});

// node_modules/@mui/x-date-pickers/MonthCalendar/PickersMonth.js
var React6, import_jsx_runtime4, _excluded4, useUtilityClasses4, PickersMonthRoot, MonthCalendarButton, PickersMonth;
var init_PickersMonth = __esm({
  "node_modules/@mui/x-date-pickers/MonthCalendar/PickersMonth.js"() {
    init_objectWithoutPropertiesLoose();
    init_extends();
    React6 = __toESM(require_react());
    init_clsx();
    init_styles();
    init_utils2();
    init_composeClasses();
    init_useEnhancedEffect();
    init_pickersMonthClasses();
    import_jsx_runtime4 = __toESM(require_jsx_runtime());
    _excluded4 = ["autoFocus", "className", "children", "disabled", "selected", "value", "tabIndex", "onClick", "onKeyDown", "onFocus", "onBlur", "aria-current", "aria-label", "monthsPerRow", "slots", "slotProps"];
    useUtilityClasses4 = (ownerState) => {
      const {
        disabled,
        selected,
        classes
      } = ownerState;
      const slots = {
        root: ["root"],
        monthButton: ["monthButton", disabled && "disabled", selected && "selected"]
      };
      return composeClasses(slots, getPickersMonthUtilityClass, classes);
    };
    PickersMonthRoot = styled_default("div", {
      name: "MuiPickersMonth",
      slot: "Root",
      overridesResolver: (_, styles) => [styles.root]
    })({
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexBasis: "33.3%",
      variants: [{
        props: {
          monthsPerRow: 4
        },
        style: {
          flexBasis: "25%"
        }
      }]
    });
    MonthCalendarButton = styled_default("button", {
      name: "MuiPickersMonth",
      slot: "MonthButton",
      overridesResolver: (_, styles) => [styles.monthButton, {
        [`&.${pickersMonthClasses.disabled}`]: styles.disabled
      }, {
        [`&.${pickersMonthClasses.selected}`]: styles.selected
      }]
    })(({
      theme
    }) => _extends({
      color: "unset",
      backgroundColor: "transparent",
      border: 0,
      outline: 0
    }, theme.typography.subtitle1, {
      margin: "8px 0",
      height: 36,
      width: 72,
      borderRadius: 18,
      cursor: "pointer",
      "&:focus": {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.action.active, theme.palette.action.hoverOpacity)
      },
      "&:hover": {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.action.active, theme.palette.action.hoverOpacity)
      },
      "&:disabled": {
        cursor: "auto",
        pointerEvents: "none"
      },
      [`&.${pickersMonthClasses.disabled}`]: {
        color: (theme.vars || theme).palette.text.secondary
      },
      [`&.${pickersMonthClasses.selected}`]: {
        color: (theme.vars || theme).palette.primary.contrastText,
        backgroundColor: (theme.vars || theme).palette.primary.main,
        "&:focus, &:hover": {
          backgroundColor: (theme.vars || theme).palette.primary.dark
        }
      }
    }));
    PickersMonth = React6.memo(function PickersMonth2(inProps) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiPickersMonth"
      });
      const {
        autoFocus,
        className,
        children,
        disabled,
        selected,
        value,
        tabIndex,
        onClick,
        onKeyDown,
        onFocus,
        onBlur,
        "aria-current": ariaCurrent,
        "aria-label": ariaLabel,
        slots,
        slotProps
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded4);
      const ref = React6.useRef(null);
      const classes = useUtilityClasses4(props);
      useEnhancedEffect_default(() => {
        var _a;
        if (autoFocus) {
          (_a = ref.current) == null ? void 0 : _a.focus();
        }
      }, [autoFocus]);
      const MonthButton = (slots == null ? void 0 : slots.monthButton) ?? MonthCalendarButton;
      const monthButtonProps = useSlotProps({
        elementType: MonthButton,
        externalSlotProps: slotProps == null ? void 0 : slotProps.monthButton,
        additionalProps: {
          children,
          disabled,
          tabIndex,
          ref,
          type: "button",
          role: "radio",
          "aria-current": ariaCurrent,
          "aria-checked": selected,
          "aria-label": ariaLabel,
          onClick: (event) => onClick(event, value),
          onKeyDown: (event) => onKeyDown(event, value),
          onFocus: (event) => onFocus(event, value),
          onBlur: (event) => onBlur(event, value)
        },
        ownerState: props,
        className: classes.monthButton
      });
      return (0, import_jsx_runtime4.jsx)(PickersMonthRoot, _extends({
        className: clsx_default(classes.root, className),
        ownerState: props
      }, other, {
        children: (0, import_jsx_runtime4.jsx)(MonthButton, _extends({}, monthButtonProps))
      }));
    });
  }
});

// node_modules/@mui/x-date-pickers/MonthCalendar/monthCalendarClasses.js
function getMonthCalendarUtilityClass(slot) {
  return generateUtilityClass("MuiMonthCalendar", slot);
}
var monthCalendarClasses;
var init_monthCalendarClasses = __esm({
  "node_modules/@mui/x-date-pickers/MonthCalendar/monthCalendarClasses.js"() {
    init_utils();
    monthCalendarClasses = generateUtilityClasses("MuiMonthCalendar", ["root"]);
  }
});

// node_modules/@mui/x-date-pickers/internals/hooks/useValueWithTimezone.js
var React7, useValueWithTimezone, useControlledValueWithTimezone;
var init_useValueWithTimezone = __esm({
  "node_modules/@mui/x-date-pickers/internals/hooks/useValueWithTimezone.js"() {
    React7 = __toESM(require_react());
    init_useEventCallback();
    init_useControlled();
    init_useUtils();
    useValueWithTimezone = ({
      timezone: timezoneProp,
      value: valueProp,
      defaultValue,
      onChange,
      valueManager
    }) => {
      const utils = useUtils();
      const firstDefaultValue = React7.useRef(defaultValue);
      const inputValue = valueProp ?? firstDefaultValue.current ?? valueManager.emptyValue;
      const inputTimezone = React7.useMemo(() => valueManager.getTimezone(utils, inputValue), [utils, valueManager, inputValue]);
      const setInputTimezone = useEventCallback_default((newValue) => {
        if (inputTimezone == null) {
          return newValue;
        }
        return valueManager.setTimezone(utils, inputTimezone, newValue);
      });
      const timezoneToRender = timezoneProp ?? inputTimezone ?? "default";
      const valueWithTimezoneToRender = React7.useMemo(() => valueManager.setTimezone(utils, timezoneToRender, inputValue), [valueManager, utils, timezoneToRender, inputValue]);
      const handleValueChange = useEventCallback_default((newValue, ...otherParams) => {
        const newValueWithInputTimezone = setInputTimezone(newValue);
        onChange == null ? void 0 : onChange(newValueWithInputTimezone, ...otherParams);
      });
      return {
        value: valueWithTimezoneToRender,
        handleValueChange,
        timezone: timezoneToRender
      };
    };
    useControlledValueWithTimezone = ({
      name,
      timezone: timezoneProp,
      value: valueProp,
      defaultValue,
      onChange: onChangeProp,
      valueManager
    }) => {
      const [valueWithInputTimezone, setValue] = useControlled({
        name,
        state: "value",
        controlled: valueProp,
        default: defaultValue ?? valueManager.emptyValue
      });
      const onChange = useEventCallback_default((newValue, ...otherParams) => {
        setValue(newValue);
        onChangeProp == null ? void 0 : onChangeProp(newValue, ...otherParams);
      });
      return useValueWithTimezone({
        timezone: timezoneProp,
        value: valueWithInputTimezone,
        defaultValue: void 0,
        onChange,
        valueManager
      });
    };
  }
});

// node_modules/@mui/x-date-pickers/MonthCalendar/MonthCalendar.js
function useMonthCalendarDefaultizedProps(props, name) {
  const utils = useUtils();
  const defaultDates = useDefaultDates();
  const themeProps = useThemeProps({
    props,
    name
  });
  return _extends({
    disableFuture: false,
    disablePast: false
  }, themeProps, {
    minDate: applyDefaultDate(utils, themeProps.minDate, defaultDates.minDate),
    maxDate: applyDefaultDate(utils, themeProps.maxDate, defaultDates.maxDate)
  });
}
var React8, import_prop_types, import_jsx_runtime5, _excluded5, useUtilityClasses5, MonthCalendarRoot, MonthCalendar;
var init_MonthCalendar = __esm({
  "node_modules/@mui/x-date-pickers/MonthCalendar/MonthCalendar.js"() {
    init_objectWithoutPropertiesLoose();
    init_extends();
    React8 = __toESM(require_react());
    import_prop_types = __toESM(require_prop_types());
    init_clsx();
    init_RtlProvider();
    init_styles();
    init_utils();
    init_PickersMonth();
    init_useUtils();
    init_monthCalendarClasses();
    init_date_utils();
    init_valueManagers();
    init_getDefaultReferenceDate();
    init_useValueWithTimezone();
    init_dimensions();
    import_jsx_runtime5 = __toESM(require_jsx_runtime());
    _excluded5 = ["className", "value", "defaultValue", "referenceDate", "disabled", "disableFuture", "disablePast", "maxDate", "minDate", "onChange", "shouldDisableMonth", "readOnly", "disableHighlightToday", "autoFocus", "onMonthFocus", "hasFocus", "onFocusedViewChange", "monthsPerRow", "timezone", "gridLabelId", "slots", "slotProps"];
    useUtilityClasses5 = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"]
      };
      return composeClasses(slots, getMonthCalendarUtilityClass, classes);
    };
    MonthCalendarRoot = styled_default("div", {
      name: "MuiMonthCalendar",
      slot: "Root",
      overridesResolver: (props, styles) => styles.root
    })({
      display: "flex",
      flexWrap: "wrap",
      alignContent: "stretch",
      padding: "0 4px",
      width: DIALOG_WIDTH,
      // avoid padding increasing width over defined
      boxSizing: "border-box"
    });
    MonthCalendar = React8.forwardRef(function MonthCalendar2(inProps, ref) {
      const props = useMonthCalendarDefaultizedProps(inProps, "MuiMonthCalendar");
      const {
        className,
        value: valueProp,
        defaultValue,
        referenceDate: referenceDateProp,
        disabled,
        disableFuture,
        disablePast,
        maxDate,
        minDate,
        onChange,
        shouldDisableMonth,
        readOnly,
        autoFocus = false,
        onMonthFocus,
        hasFocus,
        onFocusedViewChange,
        monthsPerRow = 3,
        timezone: timezoneProp,
        gridLabelId,
        slots,
        slotProps
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded5);
      const {
        value,
        handleValueChange,
        timezone
      } = useControlledValueWithTimezone({
        name: "MonthCalendar",
        timezone: timezoneProp,
        value: valueProp,
        defaultValue,
        onChange,
        valueManager: singleItemValueManager
      });
      const now = useNow(timezone);
      const isRtl = useRtl();
      const utils = useUtils();
      const referenceDate = React8.useMemo(
        () => singleItemValueManager.getInitialReferenceValue({
          value,
          utils,
          props,
          timezone,
          referenceDate: referenceDateProp,
          granularity: SECTION_TYPE_GRANULARITY.month
        }),
        []
        // eslint-disable-line react-hooks/exhaustive-deps
      );
      const ownerState = props;
      const classes = useUtilityClasses5(ownerState);
      const todayMonth = React8.useMemo(() => utils.getMonth(now), [utils, now]);
      const selectedMonth = React8.useMemo(() => {
        if (value != null) {
          return utils.getMonth(value);
        }
        return null;
      }, [value, utils]);
      const [focusedMonth, setFocusedMonth] = React8.useState(() => selectedMonth || utils.getMonth(referenceDate));
      const [internalHasFocus, setInternalHasFocus] = useControlled({
        name: "MonthCalendar",
        state: "hasFocus",
        controlled: hasFocus,
        default: autoFocus ?? false
      });
      const changeHasFocus = useEventCallback_default((newHasFocus) => {
        setInternalHasFocus(newHasFocus);
        if (onFocusedViewChange) {
          onFocusedViewChange(newHasFocus);
        }
      });
      const isMonthDisabled = React8.useCallback((dateToValidate) => {
        const firstEnabledMonth = utils.startOfMonth(disablePast && utils.isAfter(now, minDate) ? now : minDate);
        const lastEnabledMonth = utils.startOfMonth(disableFuture && utils.isBefore(now, maxDate) ? now : maxDate);
        const monthToValidate = utils.startOfMonth(dateToValidate);
        if (utils.isBefore(monthToValidate, firstEnabledMonth)) {
          return true;
        }
        if (utils.isAfter(monthToValidate, lastEnabledMonth)) {
          return true;
        }
        if (!shouldDisableMonth) {
          return false;
        }
        return shouldDisableMonth(monthToValidate);
      }, [disableFuture, disablePast, maxDate, minDate, now, shouldDisableMonth, utils]);
      const handleMonthSelection = useEventCallback_default((event, month) => {
        if (readOnly) {
          return;
        }
        const newDate = utils.setMonth(value ?? referenceDate, month);
        handleValueChange(newDate);
      });
      const focusMonth = useEventCallback_default((month) => {
        if (!isMonthDisabled(utils.setMonth(value ?? referenceDate, month))) {
          setFocusedMonth(month);
          changeHasFocus(true);
          if (onMonthFocus) {
            onMonthFocus(month);
          }
        }
      });
      React8.useEffect(() => {
        setFocusedMonth((prevFocusedMonth) => selectedMonth !== null && prevFocusedMonth !== selectedMonth ? selectedMonth : prevFocusedMonth);
      }, [selectedMonth]);
      const handleKeyDown = useEventCallback_default((event, month) => {
        const monthsInYear = 12;
        const monthsInRow = 3;
        switch (event.key) {
          case "ArrowUp":
            focusMonth((monthsInYear + month - monthsInRow) % monthsInYear);
            event.preventDefault();
            break;
          case "ArrowDown":
            focusMonth((monthsInYear + month + monthsInRow) % monthsInYear);
            event.preventDefault();
            break;
          case "ArrowLeft":
            focusMonth((monthsInYear + month + (isRtl ? 1 : -1)) % monthsInYear);
            event.preventDefault();
            break;
          case "ArrowRight":
            focusMonth((monthsInYear + month + (isRtl ? -1 : 1)) % monthsInYear);
            event.preventDefault();
            break;
          default:
            break;
        }
      });
      const handleMonthFocus = useEventCallback_default((event, month) => {
        focusMonth(month);
      });
      const handleMonthBlur = useEventCallback_default((event, month) => {
        if (focusedMonth === month) {
          changeHasFocus(false);
        }
      });
      return (0, import_jsx_runtime5.jsx)(MonthCalendarRoot, _extends({
        ref,
        className: clsx_default(classes.root, className),
        ownerState,
        role: "radiogroup",
        "aria-labelledby": gridLabelId
      }, other, {
        children: getMonthsInYear(utils, value ?? referenceDate).map((month) => {
          const monthNumber = utils.getMonth(month);
          const monthText = utils.format(month, "monthShort");
          const monthLabel = utils.format(month, "month");
          const isSelected = monthNumber === selectedMonth;
          const isDisabled = disabled || isMonthDisabled(month);
          return (0, import_jsx_runtime5.jsx)(PickersMonth, {
            selected: isSelected,
            value: monthNumber,
            onClick: handleMonthSelection,
            onKeyDown: handleKeyDown,
            autoFocus: internalHasFocus && monthNumber === focusedMonth,
            disabled: isDisabled,
            tabIndex: monthNumber === focusedMonth && !isDisabled ? 0 : -1,
            onFocus: handleMonthFocus,
            onBlur: handleMonthBlur,
            "aria-current": todayMonth === monthNumber ? "date" : void 0,
            "aria-label": monthLabel,
            monthsPerRow,
            slots,
            slotProps,
            children: monthText
          }, monthText);
        })
      }));
    });
    true ? MonthCalendar.propTypes = {
      // ----------------------------- Warning --------------------------------
      // | These PropTypes are generated from the TypeScript type definitions |
      // | To update them edit the TypeScript types and run "pnpm proptypes"  |
      // ----------------------------------------------------------------------
      autoFocus: import_prop_types.default.bool,
      /**
       * Override or extend the styles applied to the component.
       */
      classes: import_prop_types.default.object,
      className: import_prop_types.default.string,
      /**
       * The default selected value.
       * Used when the component is not controlled.
       */
      defaultValue: import_prop_types.default.object,
      /**
       * If `true` picker is disabled
       */
      disabled: import_prop_types.default.bool,
      /**
       * If `true`, disable values after the current date for date components, time for time components and both for date time components.
       * @default false
       */
      disableFuture: import_prop_types.default.bool,
      /**
       * If `true`, today's date is rendering without highlighting with circle.
       * @default false
       */
      disableHighlightToday: import_prop_types.default.bool,
      /**
       * If `true`, disable values before the current date for date components, time for time components and both for date time components.
       * @default false
       */
      disablePast: import_prop_types.default.bool,
      gridLabelId: import_prop_types.default.string,
      hasFocus: import_prop_types.default.bool,
      /**
       * Maximal selectable date.
       */
      maxDate: import_prop_types.default.object,
      /**
       * Minimal selectable date.
       */
      minDate: import_prop_types.default.object,
      /**
       * Months rendered per row.
       * @default 3
       */
      monthsPerRow: import_prop_types.default.oneOf([3, 4]),
      /**
       * Callback fired when the value changes.
       * @template TDate
       * @param {TDate} value The new value.
       */
      onChange: import_prop_types.default.func,
      onFocusedViewChange: import_prop_types.default.func,
      onMonthFocus: import_prop_types.default.func,
      /**
       * If `true` picker is readonly
       */
      readOnly: import_prop_types.default.bool,
      /**
       * The date used to generate the new value when both `value` and `defaultValue` are empty.
       * @default The closest valid month using the validation props, except callbacks such as `shouldDisableMonth`.
       */
      referenceDate: import_prop_types.default.object,
      /**
       * Disable specific month.
       * @template TDate
       * @param {TDate} month The month to test.
       * @returns {boolean} If `true`, the month will be disabled.
       */
      shouldDisableMonth: import_prop_types.default.func,
      /**
       * The props used for each component slot.
       * @default {}
       */
      slotProps: import_prop_types.default.object,
      /**
       * Overridable component slots.
       * @default {}
       */
      slots: import_prop_types.default.object,
      /**
       * The system prop that allows defining system overrides as well as additional CSS styles.
       */
      sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object]),
      /**
       * Choose which timezone to use for the value.
       * Example: "default", "system", "UTC", "America/New_York".
       * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
       * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documentation} for more details.
       * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
       */
      timezone: import_prop_types.default.string,
      /**
       * The selected value.
       * Used when the component is controlled.
       */
      value: import_prop_types.default.object
    } : void 0;
  }
});

// node_modules/@mui/x-date-pickers/MonthCalendar/index.js
var init_MonthCalendar2 = __esm({
  "node_modules/@mui/x-date-pickers/MonthCalendar/index.js"() {
    init_MonthCalendar();
    init_monthCalendarClasses();
    init_pickersMonthClasses();
  }
});

// node_modules/@mui/x-date-pickers/YearCalendar/pickersYearClasses.js
function getPickersYearUtilityClass(slot) {
  return generateUtilityClass("MuiPickersYear", slot);
}
var pickersYearClasses;
var init_pickersYearClasses = __esm({
  "node_modules/@mui/x-date-pickers/YearCalendar/pickersYearClasses.js"() {
    init_utils();
    pickersYearClasses = generateUtilityClasses("MuiPickersYear", ["root", "yearButton", "selected", "disabled"]);
  }
});

// node_modules/@mui/x-date-pickers/YearCalendar/PickersYear.js
var React9, import_jsx_runtime6, _excluded6, useUtilityClasses6, PickersYearRoot, YearCalendarButton, PickersYear;
var init_PickersYear = __esm({
  "node_modules/@mui/x-date-pickers/YearCalendar/PickersYear.js"() {
    init_objectWithoutPropertiesLoose();
    init_extends();
    React9 = __toESM(require_react());
    init_clsx();
    init_styles();
    init_utils2();
    init_composeClasses();
    init_useEnhancedEffect();
    init_pickersYearClasses();
    import_jsx_runtime6 = __toESM(require_jsx_runtime());
    _excluded6 = ["autoFocus", "className", "children", "disabled", "selected", "value", "tabIndex", "onClick", "onKeyDown", "onFocus", "onBlur", "aria-current", "yearsPerRow", "slots", "slotProps"];
    useUtilityClasses6 = (ownerState) => {
      const {
        disabled,
        selected,
        classes
      } = ownerState;
      const slots = {
        root: ["root"],
        yearButton: ["yearButton", disabled && "disabled", selected && "selected"]
      };
      return composeClasses(slots, getPickersYearUtilityClass, classes);
    };
    PickersYearRoot = styled_default("div", {
      name: "MuiPickersYear",
      slot: "Root",
      overridesResolver: (_, styles) => [styles.root]
    })({
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexBasis: "33.3%",
      variants: [{
        props: {
          yearsPerRow: 4
        },
        style: {
          flexBasis: "25%"
        }
      }]
    });
    YearCalendarButton = styled_default("button", {
      name: "MuiPickersYear",
      slot: "YearButton",
      overridesResolver: (_, styles) => [styles.yearButton, {
        [`&.${pickersYearClasses.disabled}`]: styles.disabled
      }, {
        [`&.${pickersYearClasses.selected}`]: styles.selected
      }]
    })(({
      theme
    }) => _extends({
      color: "unset",
      backgroundColor: "transparent",
      border: 0,
      outline: 0
    }, theme.typography.subtitle1, {
      margin: "6px 0",
      height: 36,
      width: 72,
      borderRadius: 18,
      cursor: "pointer",
      "&:focus": {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.focusOpacity})` : alpha(theme.palette.action.active, theme.palette.action.focusOpacity)
      },
      "&:hover": {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.action.active, theme.palette.action.hoverOpacity)
      },
      "&:disabled": {
        cursor: "auto",
        pointerEvents: "none"
      },
      [`&.${pickersYearClasses.disabled}`]: {
        color: (theme.vars || theme).palette.text.secondary
      },
      [`&.${pickersYearClasses.selected}`]: {
        color: (theme.vars || theme).palette.primary.contrastText,
        backgroundColor: (theme.vars || theme).palette.primary.main,
        "&:focus, &:hover": {
          backgroundColor: (theme.vars || theme).palette.primary.dark
        }
      }
    }));
    PickersYear = React9.memo(function PickersYear2(inProps) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiPickersYear"
      });
      const {
        autoFocus,
        className,
        children,
        disabled,
        selected,
        value,
        tabIndex,
        onClick,
        onKeyDown,
        onFocus,
        onBlur,
        "aria-current": ariaCurrent,
        slots,
        slotProps
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded6);
      const ref = React9.useRef(null);
      const classes = useUtilityClasses6(props);
      useEnhancedEffect_default(() => {
        var _a;
        if (autoFocus) {
          (_a = ref.current) == null ? void 0 : _a.focus();
        }
      }, [autoFocus]);
      const YearButton = (slots == null ? void 0 : slots.yearButton) ?? YearCalendarButton;
      const yearButtonProps = useSlotProps({
        elementType: YearButton,
        externalSlotProps: slotProps == null ? void 0 : slotProps.yearButton,
        additionalProps: {
          children,
          disabled,
          tabIndex,
          ref,
          type: "button",
          role: "radio",
          "aria-current": ariaCurrent,
          "aria-checked": selected,
          onClick: (event) => onClick(event, value),
          onKeyDown: (event) => onKeyDown(event, value),
          onFocus: (event) => onFocus(event, value),
          onBlur: (event) => onBlur(event, value)
        },
        ownerState: props,
        className: classes.yearButton
      });
      return (0, import_jsx_runtime6.jsx)(PickersYearRoot, _extends({
        className: clsx_default(classes.root, className),
        ownerState: props
      }, other, {
        children: (0, import_jsx_runtime6.jsx)(YearButton, _extends({}, yearButtonProps))
      }));
    });
  }
});

// node_modules/@mui/x-date-pickers/YearCalendar/yearCalendarClasses.js
function getYearCalendarUtilityClass(slot) {
  return generateUtilityClass("MuiYearCalendar", slot);
}
var yearCalendarClasses;
var init_yearCalendarClasses = __esm({
  "node_modules/@mui/x-date-pickers/YearCalendar/yearCalendarClasses.js"() {
    init_utils();
    yearCalendarClasses = generateUtilityClasses("MuiYearCalendar", ["root"]);
  }
});

// node_modules/@mui/x-date-pickers/YearCalendar/YearCalendar.js
function useYearCalendarDefaultizedProps(props, name) {
  const utils = useUtils();
  const defaultDates = useDefaultDates();
  const themeProps = useThemeProps({
    props,
    name
  });
  return _extends({
    disablePast: false,
    disableFuture: false
  }, themeProps, {
    yearsPerRow: themeProps.yearsPerRow ?? 3,
    minDate: applyDefaultDate(utils, themeProps.minDate, defaultDates.minDate),
    maxDate: applyDefaultDate(utils, themeProps.maxDate, defaultDates.maxDate)
  });
}
var React10, import_prop_types2, import_jsx_runtime7, _excluded7, useUtilityClasses7, YearCalendarRoot, YearCalendar;
var init_YearCalendar = __esm({
  "node_modules/@mui/x-date-pickers/YearCalendar/YearCalendar.js"() {
    init_objectWithoutPropertiesLoose();
    init_extends();
    React10 = __toESM(require_react());
    import_prop_types2 = __toESM(require_prop_types());
    init_clsx();
    init_RtlProvider();
    init_styles();
    init_utils();
    init_PickersYear();
    init_useUtils();
    init_yearCalendarClasses();
    init_date_utils();
    init_valueManagers();
    init_getDefaultReferenceDate();
    init_useValueWithTimezone();
    init_dimensions();
    import_jsx_runtime7 = __toESM(require_jsx_runtime());
    _excluded7 = ["autoFocus", "className", "value", "defaultValue", "referenceDate", "disabled", "disableFuture", "disablePast", "maxDate", "minDate", "onChange", "readOnly", "shouldDisableYear", "disableHighlightToday", "onYearFocus", "hasFocus", "onFocusedViewChange", "yearsPerRow", "timezone", "gridLabelId", "slots", "slotProps"];
    useUtilityClasses7 = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"]
      };
      return composeClasses(slots, getYearCalendarUtilityClass, classes);
    };
    YearCalendarRoot = styled_default("div", {
      name: "MuiYearCalendar",
      slot: "Root",
      overridesResolver: (props, styles) => styles.root
    })({
      display: "flex",
      flexDirection: "row",
      flexWrap: "wrap",
      overflowY: "auto",
      height: "100%",
      padding: "0 4px",
      width: DIALOG_WIDTH,
      maxHeight: MAX_CALENDAR_HEIGHT,
      // avoid padding increasing width over defined
      boxSizing: "border-box",
      position: "relative"
    });
    YearCalendar = React10.forwardRef(function YearCalendar2(inProps, ref) {
      const props = useYearCalendarDefaultizedProps(inProps, "MuiYearCalendar");
      const {
        autoFocus,
        className,
        value: valueProp,
        defaultValue,
        referenceDate: referenceDateProp,
        disabled,
        disableFuture,
        disablePast,
        maxDate,
        minDate,
        onChange,
        readOnly,
        shouldDisableYear,
        onYearFocus,
        hasFocus,
        onFocusedViewChange,
        yearsPerRow,
        timezone: timezoneProp,
        gridLabelId,
        slots,
        slotProps
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded7);
      const {
        value,
        handleValueChange,
        timezone
      } = useControlledValueWithTimezone({
        name: "YearCalendar",
        timezone: timezoneProp,
        value: valueProp,
        defaultValue,
        onChange,
        valueManager: singleItemValueManager
      });
      const now = useNow(timezone);
      const isRtl = useRtl();
      const utils = useUtils();
      const referenceDate = React10.useMemo(
        () => singleItemValueManager.getInitialReferenceValue({
          value,
          utils,
          props,
          timezone,
          referenceDate: referenceDateProp,
          granularity: SECTION_TYPE_GRANULARITY.year
        }),
        []
        // eslint-disable-line react-hooks/exhaustive-deps
      );
      const ownerState = props;
      const classes = useUtilityClasses7(ownerState);
      const todayYear = React10.useMemo(() => utils.getYear(now), [utils, now]);
      const selectedYear = React10.useMemo(() => {
        if (value != null) {
          return utils.getYear(value);
        }
        return null;
      }, [value, utils]);
      const [focusedYear, setFocusedYear] = React10.useState(() => selectedYear || utils.getYear(referenceDate));
      const [internalHasFocus, setInternalHasFocus] = useControlled({
        name: "YearCalendar",
        state: "hasFocus",
        controlled: hasFocus,
        default: autoFocus ?? false
      });
      const changeHasFocus = useEventCallback_default((newHasFocus) => {
        setInternalHasFocus(newHasFocus);
        if (onFocusedViewChange) {
          onFocusedViewChange(newHasFocus);
        }
      });
      const isYearDisabled = React10.useCallback((dateToValidate) => {
        if (disablePast && utils.isBeforeYear(dateToValidate, now)) {
          return true;
        }
        if (disableFuture && utils.isAfterYear(dateToValidate, now)) {
          return true;
        }
        if (minDate && utils.isBeforeYear(dateToValidate, minDate)) {
          return true;
        }
        if (maxDate && utils.isAfterYear(dateToValidate, maxDate)) {
          return true;
        }
        if (!shouldDisableYear) {
          return false;
        }
        const yearToValidate = utils.startOfYear(dateToValidate);
        return shouldDisableYear(yearToValidate);
      }, [disableFuture, disablePast, maxDate, minDate, now, shouldDisableYear, utils]);
      const handleYearSelection = useEventCallback_default((event, year) => {
        if (readOnly) {
          return;
        }
        const newDate = utils.setYear(value ?? referenceDate, year);
        handleValueChange(newDate);
      });
      const focusYear = useEventCallback_default((year) => {
        if (!isYearDisabled(utils.setYear(value ?? referenceDate, year))) {
          setFocusedYear(year);
          changeHasFocus(true);
          onYearFocus == null ? void 0 : onYearFocus(year);
        }
      });
      React10.useEffect(() => {
        setFocusedYear((prevFocusedYear) => selectedYear !== null && prevFocusedYear !== selectedYear ? selectedYear : prevFocusedYear);
      }, [selectedYear]);
      const handleKeyDown = useEventCallback_default((event, year) => {
        switch (event.key) {
          case "ArrowUp":
            focusYear(year - yearsPerRow);
            event.preventDefault();
            break;
          case "ArrowDown":
            focusYear(year + yearsPerRow);
            event.preventDefault();
            break;
          case "ArrowLeft":
            focusYear(year + (isRtl ? 1 : -1));
            event.preventDefault();
            break;
          case "ArrowRight":
            focusYear(year + (isRtl ? -1 : 1));
            event.preventDefault();
            break;
          default:
            break;
        }
      });
      const handleYearFocus = useEventCallback_default((event, year) => {
        focusYear(year);
      });
      const handleYearBlur = useEventCallback_default((event, year) => {
        if (focusedYear === year) {
          changeHasFocus(false);
        }
      });
      const scrollerRef = React10.useRef(null);
      const handleRef = useForkRef(ref, scrollerRef);
      React10.useEffect(() => {
        if (autoFocus || scrollerRef.current === null) {
          return;
        }
        const tabbableButton = scrollerRef.current.querySelector('[tabindex="0"]');
        if (!tabbableButton) {
          return;
        }
        const offsetHeight = tabbableButton.offsetHeight;
        const offsetTop = tabbableButton.offsetTop;
        const clientHeight = scrollerRef.current.clientHeight;
        const scrollTop = scrollerRef.current.scrollTop;
        const elementBottom = offsetTop + offsetHeight;
        if (offsetHeight > clientHeight || offsetTop < scrollTop) {
          return;
        }
        scrollerRef.current.scrollTop = elementBottom - clientHeight / 2 - offsetHeight / 2;
      }, [autoFocus]);
      return (0, import_jsx_runtime7.jsx)(YearCalendarRoot, _extends({
        ref: handleRef,
        className: clsx_default(classes.root, className),
        ownerState,
        role: "radiogroup",
        "aria-labelledby": gridLabelId
      }, other, {
        children: utils.getYearRange([minDate, maxDate]).map((year) => {
          const yearNumber = utils.getYear(year);
          const isSelected = yearNumber === selectedYear;
          const isDisabled = disabled || isYearDisabled(year);
          return (0, import_jsx_runtime7.jsx)(PickersYear, {
            selected: isSelected,
            value: yearNumber,
            onClick: handleYearSelection,
            onKeyDown: handleKeyDown,
            autoFocus: internalHasFocus && yearNumber === focusedYear,
            disabled: isDisabled,
            tabIndex: yearNumber === focusedYear && !isDisabled ? 0 : -1,
            onFocus: handleYearFocus,
            onBlur: handleYearBlur,
            "aria-current": todayYear === yearNumber ? "date" : void 0,
            yearsPerRow,
            slots,
            slotProps,
            children: utils.format(year, "year")
          }, utils.format(year, "year"));
        })
      }));
    });
    true ? YearCalendar.propTypes = {
      // ----------------------------- Warning --------------------------------
      // | These PropTypes are generated from the TypeScript type definitions |
      // | To update them edit the TypeScript types and run "pnpm proptypes"  |
      // ----------------------------------------------------------------------
      autoFocus: import_prop_types2.default.bool,
      /**
       * Override or extend the styles applied to the component.
       */
      classes: import_prop_types2.default.object,
      className: import_prop_types2.default.string,
      /**
       * The default selected value.
       * Used when the component is not controlled.
       */
      defaultValue: import_prop_types2.default.object,
      /**
       * If `true` picker is disabled
       */
      disabled: import_prop_types2.default.bool,
      /**
       * If `true`, disable values after the current date for date components, time for time components and both for date time components.
       * @default false
       */
      disableFuture: import_prop_types2.default.bool,
      /**
       * If `true`, today's date is rendering without highlighting with circle.
       * @default false
       */
      disableHighlightToday: import_prop_types2.default.bool,
      /**
       * If `true`, disable values before the current date for date components, time for time components and both for date time components.
       * @default false
       */
      disablePast: import_prop_types2.default.bool,
      gridLabelId: import_prop_types2.default.string,
      hasFocus: import_prop_types2.default.bool,
      /**
       * Maximal selectable date.
       */
      maxDate: import_prop_types2.default.object,
      /**
       * Minimal selectable date.
       */
      minDate: import_prop_types2.default.object,
      /**
       * Callback fired when the value changes.
       * @template TDate
       * @param {TDate} value The new value.
       */
      onChange: import_prop_types2.default.func,
      onFocusedViewChange: import_prop_types2.default.func,
      onYearFocus: import_prop_types2.default.func,
      /**
       * If `true` picker is readonly
       */
      readOnly: import_prop_types2.default.bool,
      /**
       * The date used to generate the new value when both `value` and `defaultValue` are empty.
       * @default The closest valid year using the validation props, except callbacks such as `shouldDisableYear`.
       */
      referenceDate: import_prop_types2.default.object,
      /**
       * Disable specific year.
       * @template TDate
       * @param {TDate} year The year to test.
       * @returns {boolean} If `true`, the year will be disabled.
       */
      shouldDisableYear: import_prop_types2.default.func,
      /**
       * The props used for each component slot.
       * @default {}
       */
      slotProps: import_prop_types2.default.object,
      /**
       * Overridable component slots.
       * @default {}
       */
      slots: import_prop_types2.default.object,
      /**
       * The system prop that allows defining system overrides as well as additional CSS styles.
       */
      sx: import_prop_types2.default.oneOfType([import_prop_types2.default.arrayOf(import_prop_types2.default.oneOfType([import_prop_types2.default.func, import_prop_types2.default.object, import_prop_types2.default.bool])), import_prop_types2.default.func, import_prop_types2.default.object]),
      /**
       * Choose which timezone to use for the value.
       * Example: "default", "system", "UTC", "America/New_York".
       * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
       * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documentation} for more details.
       * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
       */
      timezone: import_prop_types2.default.string,
      /**
       * The selected value.
       * Used when the component is controlled.
       */
      value: import_prop_types2.default.object,
      /**
       * Years rendered per row.
       * @default 3
       */
      yearsPerRow: import_prop_types2.default.oneOf([3, 4])
    } : void 0;
  }
});

// node_modules/@mui/x-date-pickers/YearCalendar/index.js
var init_YearCalendar2 = __esm({
  "node_modules/@mui/x-date-pickers/YearCalendar/index.js"() {
    init_YearCalendar();
    init_yearCalendarClasses();
    init_pickersYearClasses();
  }
});

// node_modules/@mui/x-date-pickers/internals/hooks/useViews.js
function useViews({
  onChange,
  onViewChange,
  openTo,
  view: inView,
  views,
  autoFocus,
  focusedView: inFocusedView,
  onFocusedViewChange
}) {
  if (true) {
    if (!warnedOnceNotValidView) {
      if (inView != null && !views.includes(inView)) {
        console.warn(`MUI X: \`view="${inView}"\` is not a valid prop.`, `It must be an element of \`views=["${views.join('", "')}"]\`.`);
        warnedOnceNotValidView = true;
      }
      if (inView == null && openTo != null && !views.includes(openTo)) {
        console.warn(`MUI X: \`openTo="${openTo}"\` is not a valid prop.`, `It must be an element of \`views=["${views.join('", "')}"]\`.`);
        warnedOnceNotValidView = true;
      }
    }
  }
  const previousOpenTo = React11.useRef(openTo);
  const previousViews = React11.useRef(views);
  const defaultView = React11.useRef(views.includes(openTo) ? openTo : views[0]);
  const [view, setView] = useControlled({
    name: "useViews",
    state: "view",
    controlled: inView,
    default: defaultView.current
  });
  const defaultFocusedView = React11.useRef(autoFocus ? view : null);
  const [focusedView, setFocusedView] = useControlled({
    name: "useViews",
    state: "focusedView",
    controlled: inFocusedView,
    default: defaultFocusedView.current
  });
  React11.useEffect(() => {
    if (previousOpenTo.current && previousOpenTo.current !== openTo || previousViews.current && previousViews.current.some((previousView2) => !views.includes(previousView2))) {
      setView(views.includes(openTo) ? openTo : views[0]);
      previousViews.current = views;
      previousOpenTo.current = openTo;
    }
  }, [openTo, setView, view, views]);
  const viewIndex = views.indexOf(view);
  const previousView = views[viewIndex - 1] ?? null;
  const nextView = views[viewIndex + 1] ?? null;
  const handleFocusedViewChange = useEventCallback_default((viewToFocus, hasFocus) => {
    if (hasFocus) {
      setFocusedView(viewToFocus);
    } else {
      setFocusedView(
        (prevFocusedView) => viewToFocus === prevFocusedView ? null : prevFocusedView
        // If false the blur is due to view switching
      );
    }
    onFocusedViewChange == null ? void 0 : onFocusedViewChange(viewToFocus, hasFocus);
  });
  const handleChangeView = useEventCallback_default((newView) => {
    handleFocusedViewChange(newView, true);
    if (newView === view) {
      return;
    }
    setView(newView);
    if (onViewChange) {
      onViewChange(newView);
    }
  });
  const goToNextView = useEventCallback_default(() => {
    if (nextView) {
      handleChangeView(nextView);
    }
  });
  const setValueAndGoToNextView = useEventCallback_default((value, currentViewSelectionState, selectedView) => {
    const isSelectionFinishedOnCurrentView = currentViewSelectionState === "finish";
    const hasMoreViews = selectedView ? (
      // handles case like `DateTimePicker`, where a view might return a `finish` selection state
      // but when it's not the final view given all `views` -> overall selection state should be `partial`.
      views.indexOf(selectedView) < views.length - 1
    ) : Boolean(nextView);
    const globalSelectionState = isSelectionFinishedOnCurrentView && hasMoreViews ? "partial" : currentViewSelectionState;
    onChange(value, globalSelectionState, selectedView);
    if (selectedView && selectedView !== view) {
      const nextViewAfterSelected = views[views.indexOf(selectedView) + 1];
      if (nextViewAfterSelected) {
        handleChangeView(nextViewAfterSelected);
      }
    } else if (isSelectionFinishedOnCurrentView) {
      goToNextView();
    }
  });
  return {
    view,
    setView: handleChangeView,
    focusedView,
    setFocusedView: handleFocusedViewChange,
    nextView,
    previousView,
    // Always return up-to-date default view instead of the initial one (i.e. defaultView.current)
    defaultView: views.includes(openTo) ? openTo : views[0],
    goToNextView,
    setValueAndGoToNextView
  };
}
var React11, warnedOnceNotValidView;
var init_useViews = __esm({
  "node_modules/@mui/x-date-pickers/internals/hooks/useViews.js"() {
    React11 = __toESM(require_react());
    init_useEventCallback();
    init_utils();
    warnedOnceNotValidView = false;
  }
});

// node_modules/@mui/x-date-pickers/PickersCalendarHeader/pickersCalendarHeaderClasses.js
var getPickersCalendarHeaderUtilityClass, pickersCalendarHeaderClasses;
var init_pickersCalendarHeaderClasses = __esm({
  "node_modules/@mui/x-date-pickers/PickersCalendarHeader/pickersCalendarHeaderClasses.js"() {
    init_utils();
    getPickersCalendarHeaderUtilityClass = (slot) => generateUtilityClass("MuiPickersCalendarHeader", slot);
    pickersCalendarHeaderClasses = generateUtilityClasses("MuiPickersCalendarHeader", ["root", "labelContainer", "label", "switchViewButton", "switchViewIcon"]);
  }
});

// node_modules/@mui/x-date-pickers/icons/index.js
var React12, import_jsx_runtime8, ArrowDropDownIcon, ArrowLeftIcon, ArrowRightIcon, CalendarIcon, ClockIcon, DateRangeIcon, TimeIcon, ClearIcon;
var init_icons = __esm({
  "node_modules/@mui/x-date-pickers/icons/index.js"() {
    init_utils3();
    React12 = __toESM(require_react());
    import_jsx_runtime8 = __toESM(require_jsx_runtime());
    ArrowDropDownIcon = createSvgIcon((0, import_jsx_runtime8.jsx)("path", {
      d: "M7 10l5 5 5-5z"
    }), "ArrowDropDown");
    ArrowLeftIcon = createSvgIcon((0, import_jsx_runtime8.jsx)("path", {
      d: "M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z"
    }), "ArrowLeft");
    ArrowRightIcon = createSvgIcon((0, import_jsx_runtime8.jsx)("path", {
      d: "M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"
    }), "ArrowRight");
    CalendarIcon = createSvgIcon((0, import_jsx_runtime8.jsx)("path", {
      d: "M17 12h-5v5h5v-5zM16 1v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2h-1V1h-2zm3 18H5V8h14v11z"
    }), "Calendar");
    ClockIcon = createSvgIcon((0, import_jsx_runtime8.jsxs)(React12.Fragment, {
      children: [(0, import_jsx_runtime8.jsx)("path", {
        d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
      }), (0, import_jsx_runtime8.jsx)("path", {
        d: "M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"
      })]
    }), "Clock");
    DateRangeIcon = createSvgIcon((0, import_jsx_runtime8.jsx)("path", {
      d: "M9 11H7v2h2v-2zm4 0h-2v2h2v-2zm4 0h-2v2h2v-2zm2-7h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V9h14v11z"
    }), "DateRange");
    TimeIcon = createSvgIcon((0, import_jsx_runtime8.jsxs)(React12.Fragment, {
      children: [(0, import_jsx_runtime8.jsx)("path", {
        d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
      }), (0, import_jsx_runtime8.jsx)("path", {
        d: "M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"
      })]
    }), "Time");
    ClearIcon = createSvgIcon((0, import_jsx_runtime8.jsx)("path", {
      d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
    }), "Clear");
  }
});

// node_modules/@mui/x-date-pickers/internals/components/PickersArrowSwitcher/pickersArrowSwitcherClasses.js
function getPickersArrowSwitcherUtilityClass(slot) {
  return generateUtilityClass("MuiPickersArrowSwitcher", slot);
}
var pickersArrowSwitcherClasses;
var init_pickersArrowSwitcherClasses = __esm({
  "node_modules/@mui/x-date-pickers/internals/components/PickersArrowSwitcher/pickersArrowSwitcherClasses.js"() {
    init_utils();
    pickersArrowSwitcherClasses = generateUtilityClasses("MuiPickersArrowSwitcher", ["root", "spacer", "button"]);
  }
});

// node_modules/@mui/x-date-pickers/internals/components/PickersArrowSwitcher/PickersArrowSwitcher.js
var React13, import_jsx_runtime9, _excluded8, _excluded23, _excluded32, PickersArrowSwitcherRoot, PickersArrowSwitcherSpacer, PickersArrowSwitcherButton, useUtilityClasses8, PickersArrowSwitcher;
var init_PickersArrowSwitcher = __esm({
  "node_modules/@mui/x-date-pickers/internals/components/PickersArrowSwitcher/PickersArrowSwitcher.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    React13 = __toESM(require_react());
    init_clsx();
    init_Typography();
    init_RtlProvider();
    init_styles();
    init_utils();
    init_utils2();
    init_IconButton();
    init_icons();
    init_pickersArrowSwitcherClasses();
    import_jsx_runtime9 = __toESM(require_jsx_runtime());
    _excluded8 = ["children", "className", "slots", "slotProps", "isNextDisabled", "isNextHidden", "onGoToNext", "nextLabel", "isPreviousDisabled", "isPreviousHidden", "onGoToPrevious", "previousLabel"];
    _excluded23 = ["ownerState"];
    _excluded32 = ["ownerState"];
    PickersArrowSwitcherRoot = styled_default("div", {
      name: "MuiPickersArrowSwitcher",
      slot: "Root",
      overridesResolver: (props, styles) => styles.root
    })({
      display: "flex"
    });
    PickersArrowSwitcherSpacer = styled_default("div", {
      name: "MuiPickersArrowSwitcher",
      slot: "Spacer",
      overridesResolver: (props, styles) => styles.spacer
    })(({
      theme
    }) => ({
      width: theme.spacing(3)
    }));
    PickersArrowSwitcherButton = styled_default(IconButton_default, {
      name: "MuiPickersArrowSwitcher",
      slot: "Button",
      overridesResolver: (props, styles) => styles.button
    })({
      variants: [{
        props: {
          hidden: true
        },
        style: {
          visibility: "hidden"
        }
      }]
    });
    useUtilityClasses8 = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"],
        spacer: ["spacer"],
        button: ["button"]
      };
      return composeClasses(slots, getPickersArrowSwitcherUtilityClass, classes);
    };
    PickersArrowSwitcher = React13.forwardRef(function PickersArrowSwitcher2(inProps, ref) {
      const isRtl = useRtl();
      const props = useThemeProps({
        props: inProps,
        name: "MuiPickersArrowSwitcher"
      });
      const {
        children,
        className,
        slots,
        slotProps,
        isNextDisabled,
        isNextHidden,
        onGoToNext,
        nextLabel,
        isPreviousDisabled,
        isPreviousHidden,
        onGoToPrevious,
        previousLabel
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded8);
      const ownerState = props;
      const classes = useUtilityClasses8(ownerState);
      const nextProps = {
        isDisabled: isNextDisabled,
        isHidden: isNextHidden,
        goTo: onGoToNext,
        label: nextLabel
      };
      const previousProps = {
        isDisabled: isPreviousDisabled,
        isHidden: isPreviousHidden,
        goTo: onGoToPrevious,
        label: previousLabel
      };
      const PreviousIconButton = (slots == null ? void 0 : slots.previousIconButton) ?? PickersArrowSwitcherButton;
      const previousIconButtonProps = useSlotProps({
        elementType: PreviousIconButton,
        externalSlotProps: slotProps == null ? void 0 : slotProps.previousIconButton,
        additionalProps: {
          size: "medium",
          title: previousProps.label,
          "aria-label": previousProps.label,
          disabled: previousProps.isDisabled,
          edge: "end",
          onClick: previousProps.goTo
        },
        ownerState: _extends({}, ownerState, {
          hidden: previousProps.isHidden
        }),
        className: classes.button
      });
      const NextIconButton = (slots == null ? void 0 : slots.nextIconButton) ?? PickersArrowSwitcherButton;
      const nextIconButtonProps = useSlotProps({
        elementType: NextIconButton,
        externalSlotProps: slotProps == null ? void 0 : slotProps.nextIconButton,
        additionalProps: {
          size: "medium",
          title: nextProps.label,
          "aria-label": nextProps.label,
          disabled: nextProps.isDisabled,
          edge: "start",
          onClick: nextProps.goTo
        },
        ownerState: _extends({}, ownerState, {
          hidden: nextProps.isHidden
        }),
        className: classes.button
      });
      const LeftArrowIcon = (slots == null ? void 0 : slots.leftArrowIcon) ?? ArrowLeftIcon;
      const _useSlotProps = useSlotProps({
        elementType: LeftArrowIcon,
        externalSlotProps: slotProps == null ? void 0 : slotProps.leftArrowIcon,
        additionalProps: {
          fontSize: "inherit"
        },
        ownerState: void 0
      }), leftArrowIconProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded23);
      const RightArrowIcon = (slots == null ? void 0 : slots.rightArrowIcon) ?? ArrowRightIcon;
      const _useSlotProps2 = useSlotProps({
        elementType: RightArrowIcon,
        externalSlotProps: slotProps == null ? void 0 : slotProps.rightArrowIcon,
        additionalProps: {
          fontSize: "inherit"
        },
        ownerState: void 0
      }), rightArrowIconProps = _objectWithoutPropertiesLoose(_useSlotProps2, _excluded32);
      return (0, import_jsx_runtime9.jsxs)(PickersArrowSwitcherRoot, _extends({
        ref,
        className: clsx_default(classes.root, className),
        ownerState
      }, other, {
        children: [(0, import_jsx_runtime9.jsx)(PreviousIconButton, _extends({}, previousIconButtonProps, {
          children: isRtl ? (0, import_jsx_runtime9.jsx)(RightArrowIcon, _extends({}, rightArrowIconProps)) : (0, import_jsx_runtime9.jsx)(LeftArrowIcon, _extends({}, leftArrowIconProps))
        })), children ? (0, import_jsx_runtime9.jsx)(Typography_default, {
          variant: "subtitle1",
          component: "span",
          children
        }) : (0, import_jsx_runtime9.jsx)(PickersArrowSwitcherSpacer, {
          className: classes.spacer,
          ownerState
        }), (0, import_jsx_runtime9.jsx)(NextIconButton, _extends({}, nextIconButtonProps, {
          children: isRtl ? (0, import_jsx_runtime9.jsx)(LeftArrowIcon, _extends({}, leftArrowIconProps)) : (0, import_jsx_runtime9.jsx)(RightArrowIcon, _extends({}, rightArrowIconProps))
        }))]
      }));
    });
  }
});

// node_modules/@mui/x-date-pickers/internals/components/PickersArrowSwitcher/index.js
var init_PickersArrowSwitcher2 = __esm({
  "node_modules/@mui/x-date-pickers/internals/components/PickersArrowSwitcher/index.js"() {
    init_PickersArrowSwitcher();
    init_pickersArrowSwitcherClasses();
  }
});

// node_modules/@mui/x-date-pickers/internals/hooks/date-helpers-hooks.js
function useNextMonthDisabled(month, {
  disableFuture,
  maxDate,
  timezone
}) {
  const utils = useUtils();
  return React14.useMemo(() => {
    const now = utils.date(void 0, timezone);
    const lastEnabledMonth = utils.startOfMonth(disableFuture && utils.isBefore(now, maxDate) ? now : maxDate);
    return !utils.isAfter(lastEnabledMonth, month);
  }, [disableFuture, maxDate, month, utils, timezone]);
}
function usePreviousMonthDisabled(month, {
  disablePast,
  minDate,
  timezone
}) {
  const utils = useUtils();
  return React14.useMemo(() => {
    const now = utils.date(void 0, timezone);
    const firstEnabledMonth = utils.startOfMonth(disablePast && utils.isAfter(now, minDate) ? now : minDate);
    return !utils.isBefore(firstEnabledMonth, month);
  }, [disablePast, minDate, month, utils, timezone]);
}
function useMeridiemMode(date, ampm, onChange, selectionState) {
  const utils = useUtils();
  const meridiemMode = getMeridiem(date, utils);
  const handleMeridiemChange = React14.useCallback((mode) => {
    const timeWithMeridiem = date == null ? null : convertToMeridiem(date, mode, Boolean(ampm), utils);
    onChange(timeWithMeridiem, selectionState ?? "partial");
  }, [ampm, date, onChange, selectionState, utils]);
  return {
    meridiemMode,
    handleMeridiemChange
  };
}
var React14;
var init_date_helpers_hooks = __esm({
  "node_modules/@mui/x-date-pickers/internals/hooks/date-helpers-hooks.js"() {
    React14 = __toESM(require_react());
    init_useUtils();
    init_time_utils();
  }
});

// node_modules/@mui/x-date-pickers/PickersCalendarHeader/PickersCalendarHeader.js
var React15, import_prop_types3, import_jsx_runtime10, _excluded9, _excluded24, useUtilityClasses9, PickersCalendarHeaderRoot, PickersCalendarHeaderLabelContainer, PickersCalendarHeaderLabel, PickersCalendarHeaderSwitchViewButton, PickersCalendarHeaderSwitchViewIcon, PickersCalendarHeader;
var init_PickersCalendarHeader = __esm({
  "node_modules/@mui/x-date-pickers/PickersCalendarHeader/PickersCalendarHeader.js"() {
    init_objectWithoutPropertiesLoose();
    init_extends();
    React15 = __toESM(require_react());
    import_prop_types3 = __toESM(require_prop_types());
    init_clsx();
    init_Fade();
    init_styles();
    init_utils2();
    init_utils();
    init_IconButton();
    init_useUtils();
    init_PickersFadeTransitionGroup();
    init_icons();
    init_PickersArrowSwitcher2();
    init_date_helpers_hooks();
    init_pickersCalendarHeaderClasses();
    import_jsx_runtime10 = __toESM(require_jsx_runtime());
    _excluded9 = ["slots", "slotProps", "currentMonth", "disabled", "disableFuture", "disablePast", "maxDate", "minDate", "onMonthChange", "onViewChange", "view", "reduceAnimations", "views", "labelId", "className", "timezone", "format"];
    _excluded24 = ["ownerState"];
    useUtilityClasses9 = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"],
        labelContainer: ["labelContainer"],
        label: ["label"],
        switchViewButton: ["switchViewButton"],
        switchViewIcon: ["switchViewIcon"]
      };
      return composeClasses(slots, getPickersCalendarHeaderUtilityClass, classes);
    };
    PickersCalendarHeaderRoot = styled_default("div", {
      name: "MuiPickersCalendarHeader",
      slot: "Root",
      overridesResolver: (_, styles) => styles.root
    })({
      display: "flex",
      alignItems: "center",
      marginTop: 12,
      marginBottom: 4,
      paddingLeft: 24,
      paddingRight: 12,
      // prevent jumping in safari
      maxHeight: 40,
      minHeight: 40
    });
    PickersCalendarHeaderLabelContainer = styled_default("div", {
      name: "MuiPickersCalendarHeader",
      slot: "LabelContainer",
      overridesResolver: (_, styles) => styles.labelContainer
    })(({
      theme
    }) => _extends({
      display: "flex",
      overflow: "hidden",
      alignItems: "center",
      cursor: "pointer",
      marginRight: "auto"
    }, theme.typography.body1, {
      fontWeight: theme.typography.fontWeightMedium
    }));
    PickersCalendarHeaderLabel = styled_default("div", {
      name: "MuiPickersCalendarHeader",
      slot: "Label",
      overridesResolver: (_, styles) => styles.label
    })({
      marginRight: 6
    });
    PickersCalendarHeaderSwitchViewButton = styled_default(IconButton_default, {
      name: "MuiPickersCalendarHeader",
      slot: "SwitchViewButton",
      overridesResolver: (_, styles) => styles.switchViewButton
    })({
      marginRight: "auto",
      variants: [{
        props: {
          view: "year"
        },
        style: {
          [`.${pickersCalendarHeaderClasses.switchViewIcon}`]: {
            transform: "rotate(180deg)"
          }
        }
      }]
    });
    PickersCalendarHeaderSwitchViewIcon = styled_default(ArrowDropDownIcon, {
      name: "MuiPickersCalendarHeader",
      slot: "SwitchViewIcon",
      overridesResolver: (_, styles) => styles.switchViewIcon
    })(({
      theme
    }) => ({
      willChange: "transform",
      transition: theme.transitions.create("transform"),
      transform: "rotate(0deg)"
    }));
    PickersCalendarHeader = React15.forwardRef(function PickersCalendarHeader2(inProps, ref) {
      const localeText = useLocaleText();
      const utils = useUtils();
      const props = useThemeProps({
        props: inProps,
        name: "MuiPickersCalendarHeader"
      });
      const {
        slots,
        slotProps,
        currentMonth: month,
        disabled,
        disableFuture,
        disablePast,
        maxDate,
        minDate,
        onMonthChange,
        onViewChange,
        view,
        reduceAnimations,
        views,
        labelId,
        className,
        timezone,
        format = `${utils.formats.month} ${utils.formats.year}`
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded9);
      const ownerState = props;
      const classes = useUtilityClasses9(props);
      const SwitchViewButton = (slots == null ? void 0 : slots.switchViewButton) ?? PickersCalendarHeaderSwitchViewButton;
      const switchViewButtonProps = useSlotProps({
        elementType: SwitchViewButton,
        externalSlotProps: slotProps == null ? void 0 : slotProps.switchViewButton,
        additionalProps: {
          size: "small",
          "aria-label": localeText.calendarViewSwitchingButtonAriaLabel(view)
        },
        ownerState,
        className: classes.switchViewButton
      });
      const SwitchViewIcon = (slots == null ? void 0 : slots.switchViewIcon) ?? PickersCalendarHeaderSwitchViewIcon;
      const _useSlotProps = useSlotProps({
        elementType: SwitchViewIcon,
        externalSlotProps: slotProps == null ? void 0 : slotProps.switchViewIcon,
        ownerState: void 0,
        className: classes.switchViewIcon
      }), switchViewIconProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded24);
      const selectNextMonth = () => onMonthChange(utils.addMonths(month, 1), "left");
      const selectPreviousMonth = () => onMonthChange(utils.addMonths(month, -1), "right");
      const isNextMonthDisabled = useNextMonthDisabled(month, {
        disableFuture,
        maxDate,
        timezone
      });
      const isPreviousMonthDisabled = usePreviousMonthDisabled(month, {
        disablePast,
        minDate,
        timezone
      });
      const handleToggleView = () => {
        if (views.length === 1 || !onViewChange || disabled) {
          return;
        }
        if (views.length === 2) {
          onViewChange(views.find((el) => el !== view) || views[0]);
        } else {
          const nextIndexToOpen = views.indexOf(view) !== 0 ? 0 : 1;
          onViewChange(views[nextIndexToOpen]);
        }
      };
      if (views.length === 1 && views[0] === "year") {
        return null;
      }
      const label = utils.formatByString(month, format);
      return (0, import_jsx_runtime10.jsxs)(PickersCalendarHeaderRoot, _extends({}, other, {
        ownerState,
        className: clsx_default(className, classes.root),
        ref,
        children: [(0, import_jsx_runtime10.jsxs)(PickersCalendarHeaderLabelContainer, {
          role: "presentation",
          onClick: handleToggleView,
          ownerState,
          "aria-live": "polite",
          className: classes.labelContainer,
          children: [(0, import_jsx_runtime10.jsx)(PickersFadeTransitionGroup, {
            reduceAnimations,
            transKey: label,
            children: (0, import_jsx_runtime10.jsx)(PickersCalendarHeaderLabel, {
              id: labelId,
              ownerState,
              className: classes.label,
              children: label
            })
          }), views.length > 1 && !disabled && (0, import_jsx_runtime10.jsx)(SwitchViewButton, _extends({}, switchViewButtonProps, {
            children: (0, import_jsx_runtime10.jsx)(SwitchViewIcon, _extends({}, switchViewIconProps))
          }))]
        }), (0, import_jsx_runtime10.jsx)(Fade_default, {
          in: view === "day",
          children: (0, import_jsx_runtime10.jsx)(PickersArrowSwitcher, {
            slots,
            slotProps,
            onGoToPrevious: selectPreviousMonth,
            isPreviousDisabled: isPreviousMonthDisabled,
            previousLabel: localeText.previousMonth,
            onGoToNext: selectNextMonth,
            isNextDisabled: isNextMonthDisabled,
            nextLabel: localeText.nextMonth
          })
        })]
      }));
    });
    true ? PickersCalendarHeader.propTypes = {
      // ----------------------------- Warning --------------------------------
      // | These PropTypes are generated from the TypeScript type definitions |
      // | To update them edit the TypeScript types and run "pnpm proptypes"  |
      // ----------------------------------------------------------------------
      /**
       * Override or extend the styles applied to the component.
       */
      classes: import_prop_types3.default.object,
      className: import_prop_types3.default.string,
      currentMonth: import_prop_types3.default.object.isRequired,
      disabled: import_prop_types3.default.bool,
      disableFuture: import_prop_types3.default.bool,
      disablePast: import_prop_types3.default.bool,
      /**
       * Format used to display the date.
       * @default `${adapter.formats.month} ${adapter.formats.year}`
       */
      format: import_prop_types3.default.string,
      labelId: import_prop_types3.default.string,
      maxDate: import_prop_types3.default.object.isRequired,
      minDate: import_prop_types3.default.object.isRequired,
      onMonthChange: import_prop_types3.default.func.isRequired,
      onViewChange: import_prop_types3.default.func,
      reduceAnimations: import_prop_types3.default.bool.isRequired,
      /**
       * The props used for each component slot.
       * @default {}
       */
      slotProps: import_prop_types3.default.object,
      /**
       * Overridable component slots.
       * @default {}
       */
      slots: import_prop_types3.default.object,
      /**
       * The system prop that allows defining system overrides as well as additional CSS styles.
       */
      sx: import_prop_types3.default.oneOfType([import_prop_types3.default.arrayOf(import_prop_types3.default.oneOfType([import_prop_types3.default.func, import_prop_types3.default.object, import_prop_types3.default.bool])), import_prop_types3.default.func, import_prop_types3.default.object]),
      timezone: import_prop_types3.default.string.isRequired,
      view: import_prop_types3.default.oneOf(["day", "month", "year"]).isRequired,
      views: import_prop_types3.default.arrayOf(import_prop_types3.default.oneOf(["day", "month", "year"]).isRequired).isRequired
    } : void 0;
  }
});

// node_modules/@mui/x-date-pickers/PickersCalendarHeader/index.js
var init_PickersCalendarHeader2 = __esm({
  "node_modules/@mui/x-date-pickers/PickersCalendarHeader/index.js"() {
    init_pickersCalendarHeaderClasses();
    init_PickersCalendarHeader();
  }
});

// node_modules/@mui/x-date-pickers/internals/components/PickerViewRoot/PickerViewRoot.js
var PickerViewRoot;
var init_PickerViewRoot = __esm({
  "node_modules/@mui/x-date-pickers/internals/components/PickerViewRoot/PickerViewRoot.js"() {
    init_styles();
    init_dimensions();
    PickerViewRoot = styled_default("div")({
      overflow: "hidden",
      width: DIALOG_WIDTH,
      maxHeight: VIEW_HEIGHT,
      display: "flex",
      flexDirection: "column",
      margin: "0 auto"
    });
  }
});

// node_modules/@mui/x-date-pickers/internals/components/PickerViewRoot/index.js
var init_PickerViewRoot2 = __esm({
  "node_modules/@mui/x-date-pickers/internals/components/PickerViewRoot/index.js"() {
    init_PickerViewRoot();
  }
});

// node_modules/@mui/x-date-pickers/internals/hooks/useDefaultReduceAnimations.js
var PREFERS_REDUCED_MOTION, mobileVersionMatches, androidVersion, iOSVersion, slowAnimationDevices, useDefaultReduceAnimations;
var init_useDefaultReduceAnimations = __esm({
  "node_modules/@mui/x-date-pickers/internals/hooks/useDefaultReduceAnimations.js"() {
    init_useMediaQuery();
    PREFERS_REDUCED_MOTION = "@media (prefers-reduced-motion: reduce)";
    mobileVersionMatches = typeof navigator !== "undefined" && navigator.userAgent.match(/android\s(\d+)|OS\s(\d+)/i);
    androidVersion = mobileVersionMatches && mobileVersionMatches[1] ? parseInt(mobileVersionMatches[1], 10) : null;
    iOSVersion = mobileVersionMatches && mobileVersionMatches[2] ? parseInt(mobileVersionMatches[2], 10) : null;
    slowAnimationDevices = androidVersion && androidVersion < 10 || iOSVersion && iOSVersion < 13 || false;
    useDefaultReduceAnimations = () => {
      const prefersReduced = useMediaQuery(PREFERS_REDUCED_MOTION, {
        defaultMatches: false
      });
      return prefersReduced || slowAnimationDevices;
    };
  }
});

// node_modules/@mui/x-date-pickers/DateCalendar/dateCalendarClasses.js
var getDateCalendarUtilityClass, dateCalendarClasses;
var init_dateCalendarClasses = __esm({
  "node_modules/@mui/x-date-pickers/DateCalendar/dateCalendarClasses.js"() {
    init_utils();
    getDateCalendarUtilityClass = (slot) => generateUtilityClass("MuiDateCalendar", slot);
    dateCalendarClasses = generateUtilityClasses("MuiDateCalendar", ["root", "viewTransitionContainer"]);
  }
});

// node_modules/@mui/x-date-pickers/DateCalendar/DateCalendar.js
function useDateCalendarDefaultizedProps(props, name) {
  const utils = useUtils();
  const defaultDates = useDefaultDates();
  const defaultReduceAnimations = useDefaultReduceAnimations();
  const themeProps = useThemeProps({
    props,
    name
  });
  return _extends({}, themeProps, {
    loading: themeProps.loading ?? false,
    disablePast: themeProps.disablePast ?? false,
    disableFuture: themeProps.disableFuture ?? false,
    openTo: themeProps.openTo ?? "day",
    views: themeProps.views ?? ["year", "day"],
    reduceAnimations: themeProps.reduceAnimations ?? defaultReduceAnimations,
    renderLoading: themeProps.renderLoading ?? (() => (0, import_jsx_runtime11.jsx)("span", {
      children: "..."
    })),
    minDate: applyDefaultDate(utils, themeProps.minDate, defaultDates.minDate),
    maxDate: applyDefaultDate(utils, themeProps.maxDate, defaultDates.maxDate)
  });
}
var React16, import_prop_types4, import_jsx_runtime11, _excluded10, useUtilityClasses10, DateCalendarRoot, DateCalendarViewTransitionContainer, DateCalendar;
var init_DateCalendar = __esm({
  "node_modules/@mui/x-date-pickers/DateCalendar/DateCalendar.js"() {
    init_objectWithoutPropertiesLoose();
    init_extends();
    React16 = __toESM(require_react());
    import_prop_types4 = __toESM(require_prop_types());
    init_clsx();
    init_utils2();
    init_styles();
    init_utils();
    init_useCalendarState();
    init_useUtils();
    init_PickersFadeTransitionGroup();
    init_DayCalendar();
    init_MonthCalendar2();
    init_YearCalendar2();
    init_useViews();
    init_PickersCalendarHeader2();
    init_date_utils();
    init_PickerViewRoot2();
    init_useDefaultReduceAnimations();
    init_dateCalendarClasses();
    init_useValueWithTimezone();
    init_valueManagers();
    init_dimensions();
    import_jsx_runtime11 = __toESM(require_jsx_runtime());
    _excluded10 = ["autoFocus", "onViewChange", "value", "defaultValue", "referenceDate", "disableFuture", "disablePast", "onChange", "onYearChange", "onMonthChange", "reduceAnimations", "shouldDisableDate", "shouldDisableMonth", "shouldDisableYear", "view", "views", "openTo", "className", "disabled", "readOnly", "minDate", "maxDate", "disableHighlightToday", "focusedView", "onFocusedViewChange", "showDaysOutsideCurrentMonth", "fixedWeekNumber", "dayOfWeekFormatter", "slots", "slotProps", "loading", "renderLoading", "displayWeekNumber", "yearsPerRow", "monthsPerRow", "timezone"];
    useUtilityClasses10 = (ownerState) => {
      const {
        classes
      } = ownerState;
      const slots = {
        root: ["root"],
        viewTransitionContainer: ["viewTransitionContainer"]
      };
      return composeClasses(slots, getDateCalendarUtilityClass, classes);
    };
    DateCalendarRoot = styled_default(PickerViewRoot, {
      name: "MuiDateCalendar",
      slot: "Root",
      overridesResolver: (props, styles) => styles.root
    })({
      display: "flex",
      flexDirection: "column",
      height: VIEW_HEIGHT
    });
    DateCalendarViewTransitionContainer = styled_default(PickersFadeTransitionGroup, {
      name: "MuiDateCalendar",
      slot: "ViewTransitionContainer",
      overridesResolver: (props, styles) => styles.viewTransitionContainer
    })({});
    DateCalendar = React16.forwardRef(function DateCalendar2(inProps, ref) {
      const utils = useUtils();
      const id = useId();
      const props = useDateCalendarDefaultizedProps(inProps, "MuiDateCalendar");
      const {
        autoFocus,
        onViewChange,
        value: valueProp,
        defaultValue,
        referenceDate: referenceDateProp,
        disableFuture,
        disablePast,
        onChange,
        onYearChange,
        onMonthChange,
        reduceAnimations,
        shouldDisableDate,
        shouldDisableMonth,
        shouldDisableYear,
        view: inView,
        views,
        openTo,
        className,
        disabled,
        readOnly,
        minDate,
        maxDate,
        disableHighlightToday,
        focusedView: inFocusedView,
        onFocusedViewChange,
        showDaysOutsideCurrentMonth,
        fixedWeekNumber,
        dayOfWeekFormatter,
        slots,
        slotProps,
        loading,
        renderLoading,
        displayWeekNumber,
        yearsPerRow,
        monthsPerRow,
        timezone: timezoneProp
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded10);
      const {
        value,
        handleValueChange,
        timezone
      } = useControlledValueWithTimezone({
        name: "DateCalendar",
        timezone: timezoneProp,
        value: valueProp,
        defaultValue,
        onChange,
        valueManager: singleItemValueManager
      });
      const {
        view,
        setView,
        focusedView,
        setFocusedView,
        goToNextView,
        setValueAndGoToNextView
      } = useViews({
        view: inView,
        views,
        openTo,
        onChange: handleValueChange,
        onViewChange,
        autoFocus,
        focusedView: inFocusedView,
        onFocusedViewChange
      });
      const {
        referenceDate,
        calendarState,
        changeFocusedDay,
        changeMonth,
        handleChangeMonth,
        isDateDisabled,
        onMonthSwitchingAnimationEnd
      } = useCalendarState({
        value,
        referenceDate: referenceDateProp,
        reduceAnimations,
        onMonthChange,
        minDate,
        maxDate,
        shouldDisableDate,
        disablePast,
        disableFuture,
        timezone
      });
      const minDateWithDisabled = disabled && value || minDate;
      const maxDateWithDisabled = disabled && value || maxDate;
      const gridLabelId = `${id}-grid-label`;
      const hasFocus = focusedView !== null;
      const CalendarHeader = (slots == null ? void 0 : slots.calendarHeader) ?? PickersCalendarHeader;
      const calendarHeaderProps = useSlotProps({
        elementType: CalendarHeader,
        externalSlotProps: slotProps == null ? void 0 : slotProps.calendarHeader,
        additionalProps: {
          views,
          view,
          currentMonth: calendarState.currentMonth,
          onViewChange: setView,
          onMonthChange: (newMonth, direction) => handleChangeMonth({
            newMonth,
            direction
          }),
          minDate: minDateWithDisabled,
          maxDate: maxDateWithDisabled,
          disabled,
          disablePast,
          disableFuture,
          reduceAnimations,
          timezone,
          labelId: gridLabelId
        },
        ownerState: props
      });
      const handleDateMonthChange = useEventCallback_default((newDate) => {
        const startOfMonth = utils.startOfMonth(newDate);
        const endOfMonth = utils.endOfMonth(newDate);
        const closestEnabledDate = isDateDisabled(newDate) ? findClosestEnabledDate({
          utils,
          date: newDate,
          minDate: utils.isBefore(minDate, startOfMonth) ? startOfMonth : minDate,
          maxDate: utils.isAfter(maxDate, endOfMonth) ? endOfMonth : maxDate,
          disablePast,
          disableFuture,
          isDateDisabled,
          timezone
        }) : newDate;
        if (closestEnabledDate) {
          setValueAndGoToNextView(closestEnabledDate, "finish");
          onMonthChange == null ? void 0 : onMonthChange(startOfMonth);
        } else {
          goToNextView();
          changeMonth(startOfMonth);
        }
        changeFocusedDay(closestEnabledDate, true);
      });
      const handleDateYearChange = useEventCallback_default((newDate) => {
        const startOfYear = utils.startOfYear(newDate);
        const endOfYear = utils.endOfYear(newDate);
        const closestEnabledDate = isDateDisabled(newDate) ? findClosestEnabledDate({
          utils,
          date: newDate,
          minDate: utils.isBefore(minDate, startOfYear) ? startOfYear : minDate,
          maxDate: utils.isAfter(maxDate, endOfYear) ? endOfYear : maxDate,
          disablePast,
          disableFuture,
          isDateDisabled,
          timezone
        }) : newDate;
        if (closestEnabledDate) {
          setValueAndGoToNextView(closestEnabledDate, "finish");
          onYearChange == null ? void 0 : onYearChange(closestEnabledDate);
        } else {
          goToNextView();
          changeMonth(startOfYear);
        }
        changeFocusedDay(closestEnabledDate, true);
      });
      const handleSelectedDayChange = useEventCallback_default((day) => {
        if (day) {
          return handleValueChange(mergeDateAndTime(utils, day, value ?? referenceDate), "finish", view);
        }
        return handleValueChange(day, "finish", view);
      });
      React16.useEffect(() => {
        if (value != null && utils.isValid(value)) {
          changeMonth(value);
        }
      }, [value]);
      const ownerState = props;
      const classes = useUtilityClasses10(ownerState);
      const baseDateValidationProps = {
        disablePast,
        disableFuture,
        maxDate,
        minDate
      };
      const commonViewProps = {
        disableHighlightToday,
        readOnly,
        disabled,
        timezone,
        gridLabelId,
        slots,
        slotProps
      };
      const prevOpenViewRef = React16.useRef(view);
      React16.useEffect(() => {
        if (prevOpenViewRef.current === view) {
          return;
        }
        if (focusedView === prevOpenViewRef.current) {
          setFocusedView(view, true);
        }
        prevOpenViewRef.current = view;
      }, [focusedView, setFocusedView, view]);
      const selectedDays = React16.useMemo(() => [value], [value]);
      return (0, import_jsx_runtime11.jsxs)(DateCalendarRoot, _extends({
        ref,
        className: clsx_default(classes.root, className),
        ownerState
      }, other, {
        children: [(0, import_jsx_runtime11.jsx)(CalendarHeader, _extends({}, calendarHeaderProps, {
          slots,
          slotProps
        })), (0, import_jsx_runtime11.jsx)(DateCalendarViewTransitionContainer, {
          reduceAnimations,
          className: classes.viewTransitionContainer,
          transKey: view,
          ownerState,
          children: (0, import_jsx_runtime11.jsxs)("div", {
            children: [view === "year" && (0, import_jsx_runtime11.jsx)(YearCalendar, _extends({}, baseDateValidationProps, commonViewProps, {
              value,
              onChange: handleDateYearChange,
              shouldDisableYear,
              hasFocus,
              onFocusedViewChange: (isViewFocused) => setFocusedView("year", isViewFocused),
              yearsPerRow,
              referenceDate
            })), view === "month" && (0, import_jsx_runtime11.jsx)(MonthCalendar, _extends({}, baseDateValidationProps, commonViewProps, {
              hasFocus,
              className,
              value,
              onChange: handleDateMonthChange,
              shouldDisableMonth,
              onFocusedViewChange: (isViewFocused) => setFocusedView("month", isViewFocused),
              monthsPerRow,
              referenceDate
            })), view === "day" && (0, import_jsx_runtime11.jsx)(DayCalendar, _extends({}, calendarState, baseDateValidationProps, commonViewProps, {
              onMonthSwitchingAnimationEnd,
              onFocusedDayChange: changeFocusedDay,
              reduceAnimations,
              selectedDays,
              onSelectedDaysChange: handleSelectedDayChange,
              shouldDisableDate,
              shouldDisableMonth,
              shouldDisableYear,
              hasFocus,
              onFocusedViewChange: (isViewFocused) => setFocusedView("day", isViewFocused),
              showDaysOutsideCurrentMonth,
              fixedWeekNumber,
              dayOfWeekFormatter,
              displayWeekNumber,
              loading,
              renderLoading
            }))]
          })
        })]
      }));
    });
    true ? DateCalendar.propTypes = {
      // ----------------------------- Warning --------------------------------
      // | These PropTypes are generated from the TypeScript type definitions |
      // | To update them edit the TypeScript types and run "pnpm proptypes"  |
      // ----------------------------------------------------------------------
      /**
       * If `true`, the main element is focused during the first mount.
       * This main element is:
       * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
       * - the `input` element if there is a field rendered.
       */
      autoFocus: import_prop_types4.default.bool,
      /**
       * Override or extend the styles applied to the component.
       */
      classes: import_prop_types4.default.object,
      className: import_prop_types4.default.string,
      /**
       * Formats the day of week displayed in the calendar header.
       * @param {TDate} date The date of the day of week provided by the adapter.
       * @returns {string} The name to display.
       * @default (date: TDate) => adapter.format(date, 'weekdayShort').charAt(0).toUpperCase()
       */
      dayOfWeekFormatter: import_prop_types4.default.func,
      /**
       * The default selected value.
       * Used when the component is not controlled.
       */
      defaultValue: import_prop_types4.default.object,
      /**
       * If `true`, the picker and text field are disabled.
       * @default false
       */
      disabled: import_prop_types4.default.bool,
      /**
       * If `true`, disable values after the current date for date components, time for time components and both for date time components.
       * @default false
       */
      disableFuture: import_prop_types4.default.bool,
      /**
       * If `true`, today's date is rendering without highlighting with circle.
       * @default false
       */
      disableHighlightToday: import_prop_types4.default.bool,
      /**
       * If `true`, disable values before the current date for date components, time for time components and both for date time components.
       * @default false
       */
      disablePast: import_prop_types4.default.bool,
      /**
       * If `true`, the week number will be display in the calendar.
       */
      displayWeekNumber: import_prop_types4.default.bool,
      /**
       * The day view will show as many weeks as needed after the end of the current month to match this value.
       * Put it to 6 to have a fixed number of weeks in Gregorian calendars
       */
      fixedWeekNumber: import_prop_types4.default.number,
      /**
       * Controlled focused view.
       */
      focusedView: import_prop_types4.default.oneOf(["day", "month", "year"]),
      /**
       * If `true`, calls `renderLoading` instead of rendering the day calendar.
       * Can be used to preload information and show it in calendar.
       * @default false
       */
      loading: import_prop_types4.default.bool,
      /**
       * Maximal selectable date.
       */
      maxDate: import_prop_types4.default.object,
      /**
       * Minimal selectable date.
       */
      minDate: import_prop_types4.default.object,
      /**
       * Months rendered per row.
       * @default 3
       */
      monthsPerRow: import_prop_types4.default.oneOf([3, 4]),
      /**
       * Callback fired when the value changes.
       * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
       * @template TView The view type. Will be one of date or time views.
       * @param {TValue} value The new value.
       * @param {PickerSelectionState | undefined} selectionState Indicates if the date selection is complete.
       * @param {TView | undefined} selectedView Indicates the view in which the selection has been made.
       */
      onChange: import_prop_types4.default.func,
      /**
       * Callback fired on focused view change.
       * @template TView
       * @param {TView} view The new view to focus or not.
       * @param {boolean} hasFocus `true` if the view should be focused.
       */
      onFocusedViewChange: import_prop_types4.default.func,
      /**
       * Callback fired on month change.
       * @template TDate
       * @param {TDate} month The new month.
       */
      onMonthChange: import_prop_types4.default.func,
      /**
       * Callback fired on view change.
       * @template TView
       * @param {TView} view The new view.
       */
      onViewChange: import_prop_types4.default.func,
      /**
       * Callback fired on year change.
       * @template TDate
       * @param {TDate} year The new year.
       */
      onYearChange: import_prop_types4.default.func,
      /**
       * The default visible view.
       * Used when the component view is not controlled.
       * Must be a valid option from `views` list.
       */
      openTo: import_prop_types4.default.oneOf(["day", "month", "year"]),
      /**
       * Make picker read only.
       * @default false
       */
      readOnly: import_prop_types4.default.bool,
      /**
       * If `true`, disable heavy animations.
       * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
       */
      reduceAnimations: import_prop_types4.default.bool,
      /**
       * The date used to generate the new value when both `value` and `defaultValue` are empty.
       * @default The closest valid date using the validation props, except callbacks such as `shouldDisableDate`.
       */
      referenceDate: import_prop_types4.default.object,
      /**
       * Component displaying when passed `loading` true.
       * @returns {React.ReactNode} The node to render when loading.
       * @default () => <span data-mui-test="loading-progress">...</span>
       */
      renderLoading: import_prop_types4.default.func,
      /**
       * Disable specific date.
       *
       * Warning: This function can be called multiple times (for example when rendering date calendar, checking if focus can be moved to a certain date, etc.). Expensive computations can impact performance.
       *
       * @template TDate
       * @param {TDate} day The date to test.
       * @returns {boolean} If `true` the date will be disabled.
       */
      shouldDisableDate: import_prop_types4.default.func,
      /**
       * Disable specific month.
       * @template TDate
       * @param {TDate} month The month to test.
       * @returns {boolean} If `true`, the month will be disabled.
       */
      shouldDisableMonth: import_prop_types4.default.func,
      /**
       * Disable specific year.
       * @template TDate
       * @param {TDate} year The year to test.
       * @returns {boolean} If `true`, the year will be disabled.
       */
      shouldDisableYear: import_prop_types4.default.func,
      /**
       * If `true`, days outside the current month are rendered:
       *
       * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
       *
       * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
       *
       * - ignored if `calendars` equals more than `1` on range pickers.
       * @default false
       */
      showDaysOutsideCurrentMonth: import_prop_types4.default.bool,
      /**
       * The props used for each component slot.
       * @default {}
       */
      slotProps: import_prop_types4.default.object,
      /**
       * Overridable component slots.
       * @default {}
       */
      slots: import_prop_types4.default.object,
      /**
       * The system prop that allows defining system overrides as well as additional CSS styles.
       */
      sx: import_prop_types4.default.oneOfType([import_prop_types4.default.arrayOf(import_prop_types4.default.oneOfType([import_prop_types4.default.func, import_prop_types4.default.object, import_prop_types4.default.bool])), import_prop_types4.default.func, import_prop_types4.default.object]),
      /**
       * Choose which timezone to use for the value.
       * Example: "default", "system", "UTC", "America/New_York".
       * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
       * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documentation} for more details.
       * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
       */
      timezone: import_prop_types4.default.string,
      /**
       * The selected value.
       * Used when the component is controlled.
       */
      value: import_prop_types4.default.object,
      /**
       * The visible view.
       * Used when the component view is controlled.
       * Must be a valid option from `views` list.
       */
      view: import_prop_types4.default.oneOf(["day", "month", "year"]),
      /**
       * Available views.
       */
      views: import_prop_types4.default.arrayOf(import_prop_types4.default.oneOf(["day", "month", "year"]).isRequired),
      /**
       * Years rendered per row.
       * @default 3
       */
      yearsPerRow: import_prop_types4.default.oneOf([3, 4])
    } : void 0;
  }
});

// node_modules/@mui/x-date-pickers/DateCalendar/index.js
var init_DateCalendar2 = __esm({
  "node_modules/@mui/x-date-pickers/DateCalendar/index.js"() {
    init_DateCalendar();
    init_dateCalendarClasses();
    init_dayCalendarClasses();
    init_pickersFadeTransitionGroupClasses();
    init_pickersSlideTransitionClasses();
  }
});

export {
  applyDefaultViewProps,
  init_views,
  applyDefaultDate,
  getTodayDate,
  formatMeridiem,
  isDatePickerView,
  resolveDateFormat,
  init_date_utils,
  validateDate,
  init_validateDate,
  isTimeView,
  isInternalTimeView,
  convertValueToMeridiem,
  createIsAfterIgnoreDatePart,
  resolveTimeFormat,
  init_time_utils,
  SECTION_TYPE_GRANULARITY,
  getSectionTypeGranularity,
  init_getDefaultReferenceDate,
  getDateSectionConfigFromFormatToken,
  getDaysInWeekStr,
  getLetterEditingOptions,
  getLocalizedDigits,
  removeLocalizedDigits,
  applyLocalizedDigits,
  isStringNumber,
  cleanLeadingZeros,
  cleanDigitSectionValue,
  adjustSectionValue,
  getSectionVisibleValue,
  changeSectionValueFormat,
  doesSectionFormatHaveLeadingZeros,
  getDateFromDateSections,
  getSectionsBoundaries,
  validateSections,
  mergeDateIntoReferenceDate,
  isAndroid,
  getSectionOrder,
  parseSelectedSections,
  getSectionValueText,
  getSectionValueNow,
  init_useField_utils,
  singleItemValueManager,
  singleItemFieldValueManager,
  init_valueManagers,
  init_useCalendarState,
  pickersFadeTransitionGroupClasses,
  pickersSlideTransitionClasses,
  dayCalendarClasses,
  init_DayCalendar,
  pickersMonthClasses,
  getMonthCalendarUtilityClass,
  monthCalendarClasses,
  useValueWithTimezone,
  useControlledValueWithTimezone,
  init_useValueWithTimezone,
  MonthCalendar,
  init_MonthCalendar2 as init_MonthCalendar,
  pickersYearClasses,
  getYearCalendarUtilityClass,
  yearCalendarClasses,
  YearCalendar,
  init_YearCalendar2 as init_YearCalendar,
  useViews,
  init_useViews,
  pickersCalendarHeaderClasses,
  ArrowDropDownIcon,
  ArrowLeftIcon,
  ArrowRightIcon,
  CalendarIcon,
  ClockIcon,
  DateRangeIcon,
  TimeIcon,
  ClearIcon,
  init_icons,
  init_pickersArrowSwitcherClasses,
  PickersArrowSwitcher,
  init_PickersArrowSwitcher,
  init_PickersArrowSwitcher2,
  useMeridiemMode,
  init_date_helpers_hooks,
  PickersCalendarHeader,
  init_PickersCalendarHeader2 as init_PickersCalendarHeader,
  PickerViewRoot,
  init_PickerViewRoot2 as init_PickerViewRoot,
  useDefaultReduceAnimations,
  init_useDefaultReduceAnimations,
  getDateCalendarUtilityClass,
  dateCalendarClasses,
  DateCalendar,
  init_DateCalendar2 as init_DateCalendar
};
//# sourceMappingURL=chunk-6RHPCLEJ.js.map
