import {
  ChartContainer,
  HighlightedContext,
  InteractionContext,
  ZAxisContext
} from "./chunk-W5UESXR2.js";
import {
  getValueToPositionMapper,
  useSeries
} from "./chunk-HZX2TCVT.js";
import {
  ChartsText,
  getWordsByLines
} from "./chunk-EFIGXF5V.js";
import {
  CartesianContext,
  SeriesContext,
  SvgContext,
  getLabel,
  isBandScale,
  useDrawingArea
} from "./chunk-GHO7DQJL.js";
import {
  NoSsr,
  Popper,
  init_NoSsr,
  init_Popper
} from "./chunk-BJ2O5Z5Y.js";
import {
  Typography_default,
  init_Typography
} from "./chunk-F32GU6SD.js";
import {
  init_utils as init_utils2,
  useSlotProps
} from "./chunk-U7OTEWRA.js";
import {
  init_styles,
  useTheme
} from "./chunk-ARKR4PLC.js";
import {
  init_esm,
  shouldForwardProp
} from "./chunk-ATJ2L2QU.js";
import {
  styled_default,
  useThemeProps
} from "./chunk-4ILPJN7T.js";
import {
  _objectWithoutPropertiesLoose,
  clsx_default,
  composeClasses,
  generateUtilityClass,
  generateUtilityClasses,
  init_clsx,
  init_composeClasses,
  init_generateUtilityClass,
  init_generateUtilityClasses,
  init_objectWithoutPropertiesLoose,
  init_ownerWindow,
  init_useEnhancedEffect,
  init_utils,
  ownerWindow,
  require_prop_types,
  useEnhancedEffect_default
} from "./chunk-EQAZIKX6.js";
import {
  require_jsx_runtime
} from "./chunk-PL7FREAV.js";
import {
  _extends,
  init_extends
} from "./chunk-3XPFQB6S.js";
import {
  require_react
} from "./chunk-XLKA4T3M.js";
import {
  __toESM
} from "./chunk-WXXH56N5.js";

// node_modules/@mui/x-charts/esm/ChartsTooltip/chartsTooltipClasses.js
init_utils();
function getChartsTooltipUtilityClass(slot) {
  return generateUtilityClass("MuiChartsTooltip", slot);
}
var chartsTooltipClasses = generateUtilityClasses("MuiChartsTooltip", ["root", "table", "row", "cell", "mark", "markCell", "labelCell", "valueCell"]);

// node_modules/@mui/x-charts/esm/ChartsTooltip/DefaultChartsItemTooltipContent.js
init_extends();
var React = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());
init_clsx();

// node_modules/@mui/x-charts/esm/ChartsTooltip/ChartsTooltipTable.js
init_styles();
init_esm();
var ChartsTooltipPaper = styled_default("div", {
  name: "MuiChartsTooltip",
  slot: "Container"
})(({
  theme
}) => ({
  boxShadow: theme.shadows[1],
  backgroundColor: (theme.vars || theme).palette.background.paper,
  color: (theme.vars || theme).palette.text.primary,
  transition: theme.transitions.create("box-shadow"),
  borderRadius: theme.shape.borderRadius
}));
var ChartsTooltipTable = styled_default("table", {
  name: "MuiChartsTooltip",
  slot: "Table"
})(({
  theme
}) => ({
  borderSpacing: 0,
  "& thead td": {
    borderBottom: `solid ${(theme.vars || theme).palette.divider} 1px`
  }
}));
var ChartsTooltipRow = styled_default("tr", {
  name: "MuiChartsTooltip",
  slot: "Row"
})(({
  theme
}) => ({
  "tr:first-of-type& td": {
    paddingTop: theme.spacing(1)
  },
  "tr:last-of-type& td": {
    paddingBottom: theme.spacing(1)
  }
}));
var ChartsTooltipCell = styled_default("td", {
  name: "MuiChartsTooltip",
  slot: "Cell"
})(({
  theme
}) => ({
  verticalAlign: "middle",
  color: (theme.vars || theme).palette.text.secondary,
  [`&.${chartsTooltipClasses.labelCell}`]: {
    paddingLeft: theme.spacing(1)
  },
  [`&.${chartsTooltipClasses.valueCell}`]: {
    paddingLeft: theme.spacing(4),
    color: (theme.vars || theme).palette.text.primary
  },
  "td:first-of-type&": {
    paddingLeft: theme.spacing(2)
  },
  "td:last-of-type&": {
    paddingRight: theme.spacing(2)
  }
}));
var ChartsTooltipMark = styled_default("div", {
  name: "MuiChartsTooltip",
  slot: "Mark",
  shouldForwardProp: (prop) => shouldForwardProp(prop) && prop !== "color"
})(({
  theme,
  color
}) => ({
  width: theme.spacing(1),
  height: theme.spacing(1),
  borderRadius: "50%",
  boxShadow: theme.shadows[1],
  backgroundColor: color,
  borderColor: (theme.vars || theme).palette.background.paper,
  border: `solid ${(theme.vars || theme).palette.background.paper} ${theme.spacing(0.25)}`,
  boxSizing: "content-box"
}));

// node_modules/@mui/x-charts/esm/ChartsTooltip/DefaultChartsItemTooltipContent.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
function DefaultChartsItemTooltipContent(props) {
  var _a;
  const {
    series,
    itemData,
    sx,
    classes,
    getColor: getColor6
  } = props;
  if (itemData.dataIndex === void 0 || !series.data[itemData.dataIndex]) {
    return null;
  }
  const {
    displayedLabel,
    color
  } = series.type === "pie" ? {
    color: getColor6(itemData.dataIndex),
    displayedLabel: getLabel(series.data[itemData.dataIndex].label, "tooltip")
  } : {
    color: getColor6(itemData.dataIndex) ?? series.color,
    displayedLabel: getLabel(series.label, "tooltip")
  };
  const value = series.type === "pie" ? _extends({}, series.data[itemData.dataIndex], {
    label: getLabel(series.data[itemData.dataIndex].label, "tooltip")
  }) : series.data[itemData.dataIndex];
  const formattedValue = (_a = series.valueFormatter) == null ? void 0 : _a.call(series, value, {
    dataIndex: itemData.dataIndex
  });
  return (0, import_jsx_runtime.jsx)(ChartsTooltipPaper, {
    sx,
    className: classes.root,
    children: (0, import_jsx_runtime.jsx)(ChartsTooltipTable, {
      className: classes.table,
      children: (0, import_jsx_runtime.jsx)("tbody", {
        children: (0, import_jsx_runtime.jsxs)(ChartsTooltipRow, {
          className: classes.row,
          children: [(0, import_jsx_runtime.jsx)(ChartsTooltipCell, {
            className: clsx_default(classes.markCell, classes.cell),
            children: (0, import_jsx_runtime.jsx)(ChartsTooltipMark, {
              color,
              className: classes.mark
            })
          }), (0, import_jsx_runtime.jsx)(ChartsTooltipCell, {
            className: clsx_default(classes.labelCell, classes.cell),
            children: displayedLabel
          }), (0, import_jsx_runtime.jsx)(ChartsTooltipCell, {
            className: clsx_default(classes.valueCell, classes.cell),
            children: formattedValue
          })]
        })
      })
    })
  });
}
true ? DefaultChartsItemTooltipContent.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types.default.object.isRequired,
  /**
   * Get the color of the item with index `dataIndex`.
   * @param {number} dataIndex The data index of the item.
   * @returns {string} The color to display.
   */
  getColor: import_prop_types.default.func.isRequired,
  /**
   * The data used to identify the triggered item.
   */
  itemData: import_prop_types.default.shape({
    dataIndex: import_prop_types.default.number,
    seriesId: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string]).isRequired,
    type: import_prop_types.default.oneOf(["bar", "line", "pie", "scatter"]).isRequired
  }).isRequired,
  /**
   * The series linked to the triggered axis.
   */
  series: import_prop_types.default.object.isRequired,
  sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object])
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsTooltip/ChartsItemTooltipContent.js
init_extends();
var React2 = __toESM(require_react());
var import_prop_types2 = __toESM(require_prop_types());
init_utils2();

// node_modules/@mui/x-charts/esm/BarChart/getColor.js
function getColor(series, xAxis, yAxis) {
  const verticalLayout = series.layout === "vertical";
  const bandColorScale = verticalLayout ? xAxis.colorScale : yAxis.colorScale;
  const valueColorScale = verticalLayout ? yAxis.colorScale : xAxis.colorScale;
  const bandValues = verticalLayout ? xAxis.data : yAxis.data;
  if (valueColorScale) {
    return (dataIndex) => {
      const value = series.data[dataIndex];
      const color = value === null ? series.color : valueColorScale(value);
      if (color === null) {
        return series.color;
      }
      return color;
    };
  }
  if (bandColorScale) {
    return (dataIndex) => {
      const value = bandValues[dataIndex];
      const color = value === null ? series.color : bandColorScale(value);
      if (color === null) {
        return series.color;
      }
      return color;
    };
  }
  return () => series.color;
}

// node_modules/@mui/x-charts/esm/LineChart/getColor.js
function getColor2(series, xAxis, yAxis) {
  const yColorScale = yAxis.colorScale;
  const xColorScale = xAxis.colorScale;
  if (yColorScale) {
    return (dataIndex) => {
      const value = series.data[dataIndex];
      const color = value === null ? series.color : yColorScale(value);
      if (color === null) {
        return series.color;
      }
      return color;
    };
  }
  if (xColorScale) {
    return (dataIndex) => {
      var _a;
      const value = (_a = xAxis.data) == null ? void 0 : _a[dataIndex];
      const color = value === null ? series.color : xColorScale(value);
      if (color === null) {
        return series.color;
      }
      return color;
    };
  }
  return () => series.color;
}

// node_modules/@mui/x-charts/esm/ScatterChart/getColor.js
function getColor3(series, xAxis, yAxis, zAxis) {
  const zColorScale = zAxis == null ? void 0 : zAxis.colorScale;
  const yColorScale = yAxis.colorScale;
  const xColorScale = xAxis.colorScale;
  if (zColorScale) {
    return (dataIndex) => {
      var _a, _b;
      if (((_a = zAxis == null ? void 0 : zAxis.data) == null ? void 0 : _a[dataIndex]) !== void 0) {
        const color2 = zColorScale((_b = zAxis == null ? void 0 : zAxis.data) == null ? void 0 : _b[dataIndex]);
        if (color2 !== null) {
          return color2;
        }
      }
      const value = series.data[dataIndex];
      const color = value === null ? series.color : zColorScale(value.z);
      if (color === null) {
        return series.color;
      }
      return color;
    };
  }
  if (yColorScale) {
    return (dataIndex) => {
      const value = series.data[dataIndex];
      const color = value === null ? series.color : yColorScale(value.y);
      if (color === null) {
        return series.color;
      }
      return color;
    };
  }
  if (xColorScale) {
    return (dataIndex) => {
      const value = series.data[dataIndex];
      const color = value === null ? series.color : xColorScale(value.x);
      if (color === null) {
        return series.color;
      }
      return color;
    };
  }
  return () => series.color;
}

// node_modules/@mui/x-charts/esm/PieChart/getColor.js
function getColor4(series) {
  return (dataIndex) => {
    return series.data[dataIndex].color;
  };
}

// node_modules/@mui/x-charts/esm/internals/colorGetter.js
function getColor5(series, xAxis, yAxis, zAxis) {
  if (xAxis !== void 0 && yAxis !== void 0) {
    if (series.type === "bar") {
      return getColor(series, xAxis, yAxis);
    }
    if (series.type === "line") {
      return getColor2(series, xAxis, yAxis);
    }
    if (series.type === "scatter") {
      return getColor3(series, xAxis, yAxis, zAxis);
    }
  }
  if (series.type === "pie") {
    return getColor4(series);
  }
  throw Error(`MUI X Charts: getColor called with unexpected arguments for series with id "${series.id}"`);
}
var colorGetter_default = getColor5;

// node_modules/@mui/x-charts/esm/ChartsTooltip/ChartsItemTooltipContent.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
function ChartsItemTooltipContent(props) {
  const {
    content,
    itemData,
    sx,
    classes,
    contentProps
  } = props;
  const series = React2.useContext(SeriesContext)[itemData.type].series[itemData.seriesId];
  const {
    xAxis,
    yAxis,
    xAxisIds,
    yAxisIds
  } = React2.useContext(CartesianContext);
  const {
    zAxis,
    zAxisIds
  } = React2.useContext(ZAxisContext);
  const defaultXAxisId = xAxisIds[0];
  const defaultYAxisId = yAxisIds[0];
  const defaultZAxisId = zAxisIds[0];
  let getColor6;
  switch (series.type) {
    case "pie":
      getColor6 = colorGetter_default(series);
      break;
    case "scatter":
      getColor6 = colorGetter_default(series, xAxis[series.xAxisKey ?? defaultXAxisId], yAxis[series.yAxisKey ?? defaultYAxisId], zAxis[series.zAxisKey ?? defaultZAxisId]);
      break;
    default:
      getColor6 = colorGetter_default(series, xAxis[series.xAxisKey ?? defaultXAxisId], yAxis[series.yAxisKey ?? defaultYAxisId]);
      break;
  }
  const Content = content ?? DefaultChartsItemTooltipContent;
  const chartTooltipContentProps = useSlotProps({
    elementType: Content,
    externalSlotProps: contentProps,
    additionalProps: {
      itemData,
      series,
      sx,
      classes,
      getColor: getColor6
    },
    ownerState: {}
  });
  return (0, import_jsx_runtime2.jsx)(Content, _extends({}, chartTooltipContentProps));
}
true ? ChartsItemTooltipContent.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: import_prop_types2.default.object.isRequired,
  content: import_prop_types2.default.elementType,
  contentProps: import_prop_types2.default.shape({
    classes: import_prop_types2.default.object,
    getColor: import_prop_types2.default.func,
    itemData: import_prop_types2.default.shape({
      dataIndex: import_prop_types2.default.number,
      seriesId: import_prop_types2.default.oneOfType([import_prop_types2.default.number, import_prop_types2.default.string]).isRequired,
      type: import_prop_types2.default.oneOf(["bar", "line", "pie", "scatter"]).isRequired
    }),
    series: import_prop_types2.default.object,
    sx: import_prop_types2.default.oneOfType([import_prop_types2.default.arrayOf(import_prop_types2.default.oneOfType([import_prop_types2.default.func, import_prop_types2.default.object, import_prop_types2.default.bool])), import_prop_types2.default.func, import_prop_types2.default.object])
  }),
  itemData: import_prop_types2.default.shape({
    dataIndex: import_prop_types2.default.number,
    seriesId: import_prop_types2.default.oneOfType([import_prop_types2.default.number, import_prop_types2.default.string]).isRequired,
    type: import_prop_types2.default.oneOf(["bar", "line", "pie", "scatter"]).isRequired
  }).isRequired,
  sx: import_prop_types2.default.oneOfType([import_prop_types2.default.arrayOf(import_prop_types2.default.oneOfType([import_prop_types2.default.func, import_prop_types2.default.object, import_prop_types2.default.bool])), import_prop_types2.default.func, import_prop_types2.default.object])
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsTooltip/DefaultChartsAxisTooltipContent.js
var React4 = __toESM(require_react());
var import_prop_types3 = __toESM(require_prop_types());
init_clsx();
init_Typography();

// node_modules/@mui/x-charts/esm/ChartsTooltip/utils.js
var React3 = __toESM(require_react());
function generateVirtualElement(mousePosition) {
  if (mousePosition === null) {
    return {
      getBoundingClientRect: () => ({
        width: 0,
        height: 0,
        x: 0,
        y: 0,
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        toJSON: () => ""
      })
    };
  }
  const {
    x,
    y
  } = mousePosition;
  return {
    getBoundingClientRect: () => ({
      width: 0,
      height: 0,
      x,
      y,
      top: y,
      right: x,
      bottom: y,
      left: x,
      toJSON: () => JSON.stringify({
        width: 0,
        height: 0,
        x,
        y,
        top: y,
        right: x,
        bottom: y,
        left: x
      })
    })
  };
}
function useMouseTracker() {
  const svgRef = React3.useContext(SvgContext);
  const [mousePosition, setMousePosition] = React3.useState(null);
  React3.useEffect(() => {
    const element = svgRef.current;
    if (element === null) {
      return () => {
      };
    }
    const handleOut = () => {
      setMousePosition(null);
    };
    const handleMove = (event) => {
      const target = "targetTouches" in event ? event.targetTouches[0] : event;
      setMousePosition({
        x: target.clientX,
        y: target.clientY
      });
    };
    element.addEventListener("mouseout", handleOut);
    element.addEventListener("mousemove", handleMove);
    element.addEventListener("touchend", handleOut);
    element.addEventListener("touchmove", handleMove);
    return () => {
      element.removeEventListener("mouseout", handleOut);
      element.removeEventListener("mousemove", handleMove);
      element.addEventListener("touchend", handleOut);
      element.addEventListener("touchmove", handleMove);
    };
  }, [svgRef]);
  return mousePosition;
}
function getTooltipHasData(trigger, displayedData) {
  if (trigger === "item") {
    return displayedData !== null;
  }
  const hasAxisXData = displayedData.x !== null;
  const hasAxisYData = displayedData.y !== null;
  return hasAxisXData || hasAxisYData;
}
function isCartesianSeriesType(seriesType) {
  return ["bar", "line", "scatter"].includes(seriesType);
}
function isCartesianSeries(series) {
  return isCartesianSeriesType(series.type);
}
function utcFormatter(v) {
  if (v instanceof Date) {
    return v.toUTCString();
  }
  return v.toLocaleString();
}

// node_modules/@mui/x-charts/esm/ChartsTooltip/DefaultChartsAxisTooltipContent.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
function DefaultChartsAxisTooltipContent(props) {
  const {
    series,
    axis,
    dataIndex,
    axisValue,
    sx,
    classes
  } = props;
  if (dataIndex == null) {
    return null;
  }
  const axisFormatter = axis.valueFormatter ?? ((v) => axis.scaleType === "utc" ? utcFormatter(v) : v.toLocaleString());
  return (0, import_jsx_runtime3.jsx)(ChartsTooltipPaper, {
    sx,
    className: classes.root,
    children: (0, import_jsx_runtime3.jsxs)(ChartsTooltipTable, {
      className: classes.table,
      children: [axisValue != null && !axis.hideTooltip && (0, import_jsx_runtime3.jsx)("thead", {
        children: (0, import_jsx_runtime3.jsx)(ChartsTooltipRow, {
          children: (0, import_jsx_runtime3.jsx)(ChartsTooltipCell, {
            colSpan: 3,
            children: (0, import_jsx_runtime3.jsx)(Typography_default, {
              children: axisFormatter(axisValue, {
                location: "tooltip"
              })
            })
          })
        })
      }), (0, import_jsx_runtime3.jsx)("tbody", {
        children: series.filter(isCartesianSeries).map(({
          color,
          id,
          label,
          valueFormatter,
          data,
          getColor: getColor6
        }) => {
          const formattedValue = valueFormatter(data[dataIndex] ?? null, {
            dataIndex
          });
          if (formattedValue == null) {
            return null;
          }
          const formattedLabel = getLabel(label, "tooltip");
          return (0, import_jsx_runtime3.jsxs)(ChartsTooltipRow, {
            className: classes.row,
            children: [(0, import_jsx_runtime3.jsx)(ChartsTooltipCell, {
              className: clsx_default(classes.markCell, classes.cell),
              children: (0, import_jsx_runtime3.jsx)(ChartsTooltipMark, {
                color: getColor6(dataIndex) ?? color,
                className: classes.mark
              })
            }), (0, import_jsx_runtime3.jsx)(ChartsTooltipCell, {
              className: clsx_default(classes.labelCell, classes.cell),
              children: formattedLabel ? (0, import_jsx_runtime3.jsx)(Typography_default, {
                children: formattedLabel
              }) : null
            }), (0, import_jsx_runtime3.jsx)(ChartsTooltipCell, {
              className: clsx_default(classes.valueCell, classes.cell),
              children: (0, import_jsx_runtime3.jsx)(Typography_default, {
                children: formattedValue
              })
            })]
          }, id);
        })
      })]
    })
  });
}
true ? DefaultChartsAxisTooltipContent.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The properties of the triggered axis.
   */
  axis: import_prop_types3.default.object.isRequired,
  /**
   * Data identifying the triggered axis.
   */
  axisData: import_prop_types3.default.shape({
    x: import_prop_types3.default.shape({
      index: import_prop_types3.default.number,
      value: import_prop_types3.default.oneOfType([import_prop_types3.default.instanceOf(Date), import_prop_types3.default.number, import_prop_types3.default.string]).isRequired
    }),
    y: import_prop_types3.default.shape({
      index: import_prop_types3.default.number,
      value: import_prop_types3.default.oneOfType([import_prop_types3.default.instanceOf(Date), import_prop_types3.default.number, import_prop_types3.default.string]).isRequired
    })
  }).isRequired,
  /**
   * The value associated to the current mouse position.
   */
  axisValue: import_prop_types3.default.oneOfType([import_prop_types3.default.instanceOf(Date), import_prop_types3.default.number, import_prop_types3.default.string]),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types3.default.object.isRequired,
  /**
   * The index of the data item triggered.
   */
  dataIndex: import_prop_types3.default.number,
  /**
   * The series linked to the triggered axis.
   */
  series: import_prop_types3.default.arrayOf(import_prop_types3.default.object).isRequired,
  sx: import_prop_types3.default.oneOfType([import_prop_types3.default.arrayOf(import_prop_types3.default.oneOfType([import_prop_types3.default.func, import_prop_types3.default.object, import_prop_types3.default.bool])), import_prop_types3.default.func, import_prop_types3.default.object])
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsTooltip/ChartsAxisTooltipContent.js
init_extends();
var React5 = __toESM(require_react());
var import_prop_types4 = __toESM(require_prop_types());
init_utils2();
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
function ChartsAxisTooltipContent(props) {
  const {
    content,
    contentProps,
    axisData,
    sx,
    classes
  } = props;
  const isXaxis = (axisData.x && axisData.x.index) !== void 0;
  const dataIndex = isXaxis ? axisData.x && axisData.x.index : axisData.y && axisData.y.index;
  const axisValue = isXaxis ? axisData.x && axisData.x.value : axisData.y && axisData.y.value;
  const {
    xAxisIds,
    xAxis,
    yAxisIds,
    yAxis
  } = React5.useContext(CartesianContext);
  const {
    zAxisIds,
    zAxis
  } = React5.useContext(ZAxisContext);
  const series = React5.useContext(SeriesContext);
  const USED_AXIS_ID = isXaxis ? xAxisIds[0] : yAxisIds[0];
  const relevantSeries = React5.useMemo(() => {
    const rep = [];
    Object.keys(series).filter(isCartesianSeriesType).forEach((seriesType) => {
      series[seriesType].seriesOrder.forEach((seriesId) => {
        const item = series[seriesType].series[seriesId];
        const axisKey = isXaxis ? item.xAxisKey : item.yAxisKey;
        if (axisKey === void 0 || axisKey === USED_AXIS_ID) {
          const seriesToAdd = series[seriesType].series[seriesId];
          let getColor6;
          switch (seriesToAdd.type) {
            case "scatter":
              getColor6 = colorGetter_default(seriesToAdd, xAxis[seriesToAdd.xAxisKey ?? xAxisIds[0]], yAxis[seriesToAdd.yAxisKey ?? yAxisIds[0]], zAxis[seriesToAdd.zAxisKey ?? zAxisIds[0]]);
              break;
            default:
              getColor6 = colorGetter_default(seriesToAdd, xAxis[seriesToAdd.xAxisKey ?? xAxisIds[0]], yAxis[seriesToAdd.yAxisKey ?? yAxisIds[0]]);
              break;
          }
          rep.push(_extends({}, seriesToAdd, {
            getColor: getColor6
          }));
        }
      });
    });
    return rep;
  }, [USED_AXIS_ID, isXaxis, series, xAxis, xAxisIds, yAxis, yAxisIds, zAxis, zAxisIds]);
  const relevantAxis = React5.useMemo(() => {
    return isXaxis ? xAxis[USED_AXIS_ID] : yAxis[USED_AXIS_ID];
  }, [USED_AXIS_ID, isXaxis, xAxis, yAxis]);
  const Content = content ?? DefaultChartsAxisTooltipContent;
  const chartTooltipContentProps = useSlotProps({
    elementType: Content,
    externalSlotProps: contentProps,
    additionalProps: {
      axisData,
      series: relevantSeries,
      axis: relevantAxis,
      dataIndex,
      axisValue,
      sx,
      classes
    },
    ownerState: {}
  });
  return (0, import_jsx_runtime4.jsx)(Content, _extends({}, chartTooltipContentProps));
}
true ? ChartsAxisTooltipContent.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  axisData: import_prop_types4.default.shape({
    x: import_prop_types4.default.shape({
      index: import_prop_types4.default.number,
      value: import_prop_types4.default.oneOfType([import_prop_types4.default.instanceOf(Date), import_prop_types4.default.number, import_prop_types4.default.string]).isRequired
    }),
    y: import_prop_types4.default.shape({
      index: import_prop_types4.default.number,
      value: import_prop_types4.default.oneOfType([import_prop_types4.default.instanceOf(Date), import_prop_types4.default.number, import_prop_types4.default.string]).isRequired
    })
  }).isRequired,
  classes: import_prop_types4.default.object.isRequired,
  content: import_prop_types4.default.elementType,
  contentProps: import_prop_types4.default.shape({
    axis: import_prop_types4.default.object,
    axisData: import_prop_types4.default.shape({
      x: import_prop_types4.default.shape({
        index: import_prop_types4.default.number,
        value: import_prop_types4.default.oneOfType([import_prop_types4.default.instanceOf(Date), import_prop_types4.default.number, import_prop_types4.default.string]).isRequired
      }),
      y: import_prop_types4.default.shape({
        index: import_prop_types4.default.number,
        value: import_prop_types4.default.oneOfType([import_prop_types4.default.instanceOf(Date), import_prop_types4.default.number, import_prop_types4.default.string]).isRequired
      })
    }),
    axisValue: import_prop_types4.default.oneOfType([import_prop_types4.default.instanceOf(Date), import_prop_types4.default.number, import_prop_types4.default.string]),
    classes: import_prop_types4.default.object,
    dataIndex: import_prop_types4.default.number,
    series: import_prop_types4.default.arrayOf(import_prop_types4.default.object),
    sx: import_prop_types4.default.oneOfType([import_prop_types4.default.arrayOf(import_prop_types4.default.oneOfType([import_prop_types4.default.func, import_prop_types4.default.object, import_prop_types4.default.bool])), import_prop_types4.default.func, import_prop_types4.default.object])
  }),
  sx: import_prop_types4.default.oneOfType([import_prop_types4.default.arrayOf(import_prop_types4.default.oneOfType([import_prop_types4.default.func, import_prop_types4.default.object, import_prop_types4.default.bool])), import_prop_types4.default.func, import_prop_types4.default.object])
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsTooltip/ChartsTooltip.js
init_extends();
var React6 = __toESM(require_react());
var import_prop_types5 = __toESM(require_prop_types());
init_composeClasses();
init_styles();
init_Popper();
init_NoSsr();
init_utils2();
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
var useUtilityClasses = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    table: ["table"],
    row: ["row"],
    cell: ["cell"],
    mark: ["mark"],
    markCell: ["markCell"],
    labelCell: ["labelCell"],
    valueCell: ["valueCell"]
  };
  return composeClasses(slots, getChartsTooltipUtilityClass, classes);
};
var ChartsTooltipRoot = styled_default(Popper, {
  name: "MuiChartsTooltip",
  slot: "Root",
  overridesResolver: (_, styles) => styles.root
})(({
  theme
}) => ({
  pointerEvents: "none",
  zIndex: theme.zIndex.modal
}));
function ChartsTooltip(props) {
  const themeProps = useThemeProps({
    props,
    name: "MuiChartsTooltip"
  });
  const {
    trigger = "axis",
    itemContent,
    axisContent,
    slots,
    slotProps
  } = themeProps;
  const mousePosition = useMouseTracker();
  const {
    item,
    axis
  } = React6.useContext(InteractionContext);
  const displayedData = trigger === "item" ? item : axis;
  const tooltipHasData = getTooltipHasData(trigger, displayedData);
  const popperOpen = mousePosition !== null && tooltipHasData;
  const classes = useUtilityClasses({
    classes: themeProps.classes
  });
  const PopperComponent = (slots == null ? void 0 : slots.popper) ?? ChartsTooltipRoot;
  const popperProps = useSlotProps({
    elementType: PopperComponent,
    externalSlotProps: slotProps == null ? void 0 : slotProps.popper,
    additionalProps: {
      open: popperOpen,
      placement: "right-start",
      anchorEl: generateVirtualElement(mousePosition)
    },
    ownerState: {}
  });
  if (trigger === "none") {
    return null;
  }
  return (0, import_jsx_runtime5.jsx)(NoSsr, {
    children: popperOpen && (0, import_jsx_runtime5.jsx)(PopperComponent, _extends({}, popperProps, {
      children: trigger === "item" ? (0, import_jsx_runtime5.jsx)(ChartsItemTooltipContent, {
        itemData: displayedData,
        content: (slots == null ? void 0 : slots.itemContent) ?? itemContent,
        contentProps: slotProps == null ? void 0 : slotProps.itemContent,
        sx: {
          mx: 2
        },
        classes
      }) : (0, import_jsx_runtime5.jsx)(ChartsAxisTooltipContent, {
        axisData: displayedData,
        content: (slots == null ? void 0 : slots.axisContent) ?? axisContent,
        contentProps: slotProps == null ? void 0 : slotProps.axisContent,
        sx: {
          mx: 2
        },
        classes
      })
    }))
  });
}
true ? ChartsTooltip.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Component to override the tooltip content when trigger is set to 'axis'.
   * @deprecated Use slots.axisContent instead
   */
  axisContent: import_prop_types5.default.elementType,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types5.default.object,
  /**
   * Component to override the tooltip content when trigger is set to 'item'.
   * @deprecated Use slots.itemContent instead
   */
  itemContent: import_prop_types5.default.elementType,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types5.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types5.default.object,
  /**
   * Select the kind of tooltip to display
   * - 'item': Shows data about the item below the mouse.
   * - 'axis': Shows values associated with the hovered x value
   * - 'none': Does not display tooltip
   * @default 'item'
   */
  trigger: import_prop_types5.default.oneOf(["axis", "item", "none"])
} : void 0;

// node_modules/@mui/x-charts/esm/BarChart/legend.js
var legendGetter = (params) => {
  const {
    seriesOrder,
    series
  } = params;
  return seriesOrder.reduce((acc, seriesId) => {
    const formattedLabel = getLabel(series[seriesId].label, "legend");
    if (formattedLabel === void 0) {
      return acc;
    }
    acc.push({
      color: series[seriesId].color,
      label: formattedLabel,
      id: seriesId
    });
    return acc;
  }, []);
};
var legend_default = legendGetter;

// node_modules/@mui/x-charts/esm/ScatterChart/legend.js
var legendGetter2 = (params) => {
  const {
    seriesOrder,
    series
  } = params;
  return seriesOrder.reduce((acc, seriesId) => {
    const formattedLabel = getLabel(series[seriesId].label, "legend");
    if (formattedLabel === void 0) {
      return acc;
    }
    acc.push({
      color: series[seriesId].color,
      label: formattedLabel,
      id: seriesId
    });
    return acc;
  }, []);
};
var legend_default2 = legendGetter2;

// node_modules/@mui/x-charts/esm/LineChart/legend.js
var legendGetter3 = (params) => {
  const {
    seriesOrder,
    series
  } = params;
  return seriesOrder.reduce((acc, seriesId) => {
    const formattedLabel = getLabel(series[seriesId].label, "legend");
    if (formattedLabel === void 0) {
      return acc;
    }
    acc.push({
      color: series[seriesId].color,
      label: formattedLabel,
      id: seriesId
    });
    return acc;
  }, []);
};
var legend_default3 = legendGetter3;

// node_modules/@mui/x-charts/esm/PieChart/legend.js
var legendGetter4 = (params) => {
  const {
    seriesOrder,
    series
  } = params;
  return seriesOrder.reduce((acc, seriesId) => {
    series[seriesId].data.forEach((item) => {
      const formattedLabel = getLabel(item.label, "legend");
      if (formattedLabel === void 0) {
        return;
      }
      acc.push({
        color: item.color,
        label: formattedLabel,
        id: item.id
      });
    });
    return acc;
  }, []);
};
var legend_default4 = legendGetter4;

// node_modules/@mui/x-charts/esm/ChartsLegend/utils.js
var legendGetter5 = {
  bar: legend_default,
  scatter: legend_default2,
  line: legend_default3,
  pie: legend_default4
};
function getSeriesToDisplay(series) {
  return Object.keys(series).flatMap((seriesType) => legendGetter5[seriesType](series[seriesType]));
}

// node_modules/@mui/x-charts/esm/ChartsLegend/chartsLegendClasses.js
init_utils();
function getLegendUtilityClass(slot) {
  return generateUtilityClass("MuiChartsLegend", slot);
}
var legendClasses = generateUtilityClasses("MuiChartsLegend", ["root", "series", "mark", "label", "column", "row"]);

// node_modules/@mui/x-charts/esm/ChartsLegend/DefaultChartsLegend.js
init_objectWithoutPropertiesLoose();
init_extends();
var React7 = __toESM(require_react());
var import_prop_types6 = __toESM(require_prop_types());
init_NoSsr();
init_styles();
var import_jsx_runtime6 = __toESM(require_jsx_runtime());
var _excluded = ["rotate", "dominantBaseline"];
var _excluded2 = ["label"];
var ChartsLegendRoot = styled_default("g", {
  name: "MuiChartsLegend",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})({});
var getStandardizedPadding = (padding) => {
  if (typeof padding === "number") {
    return {
      left: padding,
      right: padding,
      top: padding,
      bottom: padding
    };
  }
  return _extends({
    left: 0,
    right: 0,
    top: 0,
    bottom: 0
  }, padding);
};
function DefaultChartsLegend(props) {
  const {
    hidden,
    position,
    direction,
    seriesToDisplay,
    drawingArea,
    classes,
    itemMarkWidth = 20,
    itemMarkHeight = 20,
    markGap = 5,
    itemGap = 10,
    padding: paddingProps = 10,
    labelStyle: inLabelStyle
  } = props;
  const theme = useTheme();
  const isRTL = theme.direction === "rtl";
  const labelStyle = React7.useMemo(
    () => _extends({}, theme.typography.subtitle1, {
      color: "inherit",
      dominantBaseline: "central",
      textAnchor: "start",
      fill: (theme.vars || theme).palette.text.primary,
      lineHeight: 1
    }, inLabelStyle),
    // To say to TS that the dominantBaseline and textAnchor are correct
    [inLabelStyle, theme]
  );
  const padding = React7.useMemo(() => getStandardizedPadding(paddingProps), [paddingProps]);
  const getItemSpace = React7.useCallback((label, inStyle = {}) => {
    const style = _objectWithoutPropertiesLoose(inStyle, _excluded);
    const linesSize = getWordsByLines({
      style,
      needsComputation: true,
      text: label
    });
    const innerSize = {
      innerWidth: itemMarkWidth + markGap + Math.max(...linesSize.map((size) => size.width)),
      innerHeight: Math.max(itemMarkHeight, linesSize.length * linesSize[0].height)
    };
    return _extends({}, innerSize, {
      outerWidth: innerSize.innerWidth + itemGap,
      outerHeight: innerSize.innerHeight + itemGap
    });
  }, [itemGap, itemMarkHeight, itemMarkWidth, markGap]);
  const totalWidth = drawingArea.left + drawingArea.width + drawingArea.right;
  const totalHeight = drawingArea.top + drawingArea.height + drawingArea.bottom;
  const availableWidth = totalWidth - padding.left - padding.right;
  const availableHeight = totalHeight - padding.top - padding.bottom;
  const [seriesWithPosition, legendWidth, legendHeight] = React7.useMemo(() => {
    let x = 0;
    let y = 0;
    let totalWidthUsed = 0;
    let totalHeightUsed = 0;
    let rowIndex = 0;
    const rowMaxHeight = [0];
    const seriesWithRawPosition = seriesToDisplay.map((_ref) => {
      let {
        label
      } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded2);
      const itemSpace = getItemSpace(label, labelStyle);
      const rep = _extends({}, other, {
        label,
        positionX: x,
        positionY: y,
        innerHeight: itemSpace.innerHeight,
        innerWidth: itemSpace.innerWidth,
        outerHeight: itemSpace.outerHeight,
        outerWidth: itemSpace.outerWidth,
        rowIndex
      });
      if (direction === "row") {
        if (x + itemSpace.innerWidth > availableWidth) {
          x = 0;
          y += rowMaxHeight[rowIndex];
          rowIndex += 1;
          if (rowMaxHeight.length <= rowIndex) {
            rowMaxHeight.push(0);
          }
          rep.positionX = x;
          rep.positionY = y;
          rep.rowIndex = rowIndex;
        }
        totalWidthUsed = Math.max(totalWidthUsed, x + itemSpace.outerWidth);
        totalHeightUsed = Math.max(totalHeightUsed, y + itemSpace.outerHeight);
        rowMaxHeight[rowIndex] = Math.max(rowMaxHeight[rowIndex], itemSpace.outerHeight);
        x += itemSpace.outerWidth;
      }
      if (direction === "column") {
        if (y + itemSpace.innerHeight > availableHeight) {
          x = totalWidthUsed + itemGap;
          y = 0;
          rowIndex = 0;
          rep.positionX = x;
          rep.positionY = y;
          rep.rowIndex = rowIndex;
        }
        if (rowMaxHeight.length <= rowIndex) {
          rowMaxHeight.push(0);
        }
        totalWidthUsed = Math.max(totalWidthUsed, x + itemSpace.outerWidth);
        totalHeightUsed = Math.max(totalHeightUsed, y + itemSpace.outerHeight);
        rowIndex += 1;
        y += itemSpace.outerHeight;
      }
      return rep;
    });
    return [seriesWithRawPosition.map((item) => _extends({}, item, {
      positionY: item.positionY + (direction === "row" ? rowMaxHeight[item.rowIndex] / 2 : item.outerHeight / 2)
      // Get the center of the item
    })), totalWidthUsed, totalHeightUsed];
  }, [seriesToDisplay, getItemSpace, labelStyle, direction, availableWidth, availableHeight, itemGap]);
  const gapX = React7.useMemo(() => {
    switch (position.horizontal) {
      case "left":
        return padding.left;
      case "right":
        return totalWidth - padding.right - legendWidth;
      default:
        return (totalWidth - legendWidth) / 2;
    }
  }, [position.horizontal, padding.left, padding.right, totalWidth, legendWidth]);
  const gapY = React7.useMemo(() => {
    switch (position.vertical) {
      case "top":
        return padding.top;
      case "bottom":
        return totalHeight - padding.bottom - legendHeight;
      default:
        return (totalHeight - legendHeight) / 2;
    }
  }, [position.vertical, padding.top, padding.bottom, totalHeight, legendHeight]);
  if (hidden) {
    return null;
  }
  return (0, import_jsx_runtime6.jsx)(NoSsr, {
    children: (0, import_jsx_runtime6.jsx)(ChartsLegendRoot, {
      className: classes.root,
      children: seriesWithPosition.map(({
        id,
        label,
        color,
        positionX,
        positionY
      }) => (0, import_jsx_runtime6.jsxs)("g", {
        className: classes.series,
        transform: `translate(${gapX + (isRTL ? legendWidth - positionX : positionX)} ${gapY + positionY})`,
        children: [(0, import_jsx_runtime6.jsx)("rect", {
          className: classes.mark,
          x: isRTL ? -itemMarkWidth : 0,
          y: -itemMarkHeight / 2,
          width: itemMarkWidth,
          height: itemMarkHeight,
          fill: color
        }), (0, import_jsx_runtime6.jsx)(ChartsText, {
          style: labelStyle,
          text: label,
          x: (isRTL ? -1 : 1) * (itemMarkWidth + markGap),
          y: 0
        })]
      }, id))
    })
  });
}
true ? DefaultChartsLegend.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types6.default.object.isRequired,
  /**
   * The direction of the legend layout.
   * The default depends on the chart.
   */
  direction: import_prop_types6.default.oneOf(["column", "row"]).isRequired,
  drawingArea: import_prop_types6.default.shape({
    bottom: import_prop_types6.default.number.isRequired,
    height: import_prop_types6.default.number.isRequired,
    left: import_prop_types6.default.number.isRequired,
    right: import_prop_types6.default.number.isRequired,
    top: import_prop_types6.default.number.isRequired,
    width: import_prop_types6.default.number.isRequired
  }).isRequired,
  /**
   * Set to true to hide the legend.
   * @default false
   */
  hidden: import_prop_types6.default.bool,
  /**
   * Space between two legend items (in px).
   * @default 10
   */
  itemGap: import_prop_types6.default.number,
  /**
   * Height of the item mark (in px).
   * @default 20
   */
  itemMarkHeight: import_prop_types6.default.number,
  /**
   * Width of the item mark (in px).
   * @default 20
   */
  itemMarkWidth: import_prop_types6.default.number,
  /**
   * Style applied to legend labels.
   * @default theme.typography.subtitle1
   */
  labelStyle: import_prop_types6.default.object,
  /**
   * Space between the mark and the label (in px).
   * @default 5
   */
  markGap: import_prop_types6.default.number,
  /**
   * Legend padding (in px).
   * Can either be a single number, or an object with top, left, bottom, right properties.
   * @default 10
   */
  padding: import_prop_types6.default.oneOfType([import_prop_types6.default.number, import_prop_types6.default.shape({
    bottom: import_prop_types6.default.number,
    left: import_prop_types6.default.number,
    right: import_prop_types6.default.number,
    top: import_prop_types6.default.number
  })]),
  /**
   * The position of the legend.
   */
  position: import_prop_types6.default.shape({
    horizontal: import_prop_types6.default.oneOf(["left", "middle", "right"]).isRequired,
    vertical: import_prop_types6.default.oneOf(["bottom", "middle", "top"]).isRequired
  }).isRequired,
  series: import_prop_types6.default.object.isRequired,
  seriesToDisplay: import_prop_types6.default.arrayOf(import_prop_types6.default.shape({
    color: import_prop_types6.default.string.isRequired,
    id: import_prop_types6.default.oneOfType([import_prop_types6.default.number, import_prop_types6.default.string]).isRequired,
    label: import_prop_types6.default.string.isRequired
  })).isRequired
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsLegend/ChartsLegend.js
init_extends();
var React8 = __toESM(require_react());
var import_prop_types7 = __toESM(require_prop_types());
init_utils2();
init_utils();
init_styles();
var import_jsx_runtime7 = __toESM(require_jsx_runtime());
var useUtilityClasses2 = (ownerState) => {
  const {
    classes,
    direction
  } = ownerState;
  const slots = {
    root: ["root", direction],
    mark: ["mark"],
    label: ["label"],
    series: ["series"]
  };
  return composeClasses(slots, getLegendUtilityClass, classes);
};
var defaultProps = {
  position: {
    horizontal: "middle",
    vertical: "top"
  },
  direction: "row"
};
function ChartsLegend(inProps) {
  const props = useThemeProps({
    props: _extends({}, defaultProps, inProps),
    name: "MuiChartsLegend"
  });
  const {
    position,
    direction,
    hidden,
    slots,
    slotProps
  } = props;
  const theme = useTheme();
  const classes = useUtilityClasses2(_extends({}, props, {
    theme
  }));
  const drawingArea = useDrawingArea();
  const series = React8.useContext(SeriesContext);
  const seriesToDisplay = getSeriesToDisplay(series);
  const ChartLegendRender = (slots == null ? void 0 : slots.legend) ?? DefaultChartsLegend;
  const chartLegendRenderProps = useSlotProps({
    elementType: ChartLegendRender,
    externalSlotProps: slotProps == null ? void 0 : slotProps.legend,
    additionalProps: {
      position,
      direction,
      classes,
      drawingArea,
      series,
      hidden,
      seriesToDisplay
    },
    ownerState: {}
  });
  return (0, import_jsx_runtime7.jsx)(ChartLegendRender, _extends({}, chartLegendRenderProps));
}
true ? ChartsLegend.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types7.default.object,
  /**
   * The direction of the legend layout.
   * The default depends on the chart.
   */
  direction: import_prop_types7.default.oneOf(["column", "row"]),
  /**
   * Set to true to hide the legend.
   * @default false
   */
  hidden: import_prop_types7.default.bool,
  /**
   * The position of the legend.
   */
  position: import_prop_types7.default.shape({
    horizontal: import_prop_types7.default.oneOf(["left", "middle", "right"]).isRequired,
    vertical: import_prop_types7.default.oneOf(["bottom", "middle", "top"]).isRequired
  }),
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types7.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types7.default.object
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsAxisHighlight/ChartsAxisHighlight.js
init_extends();
var React9 = __toESM(require_react());
var import_prop_types8 = __toESM(require_prop_types());
init_composeClasses();
init_generateUtilityClass();
init_generateUtilityClasses();
init_styles();
var import_jsx_runtime8 = __toESM(require_jsx_runtime());
function getAxisHighlightUtilityClass(slot) {
  return generateUtilityClass("MuiChartsAxisHighlight", slot);
}
var chartsAxisHighlightClasses = generateUtilityClasses("MuiChartsAxisHighlight", ["root"]);
var useUtilityClasses3 = () => {
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getAxisHighlightUtilityClass);
};
var ChartsAxisHighlightPath = styled_default("path", {
  name: "MuiChartsAxisHighlight",
  slot: "Root",
  overridesResolver: (_, styles) => styles.root
})(({
  ownerState,
  theme
}) => _extends({
  pointerEvents: "none"
}, ownerState.axisHighlight === "band" && {
  fill: theme.palette.mode === "light" ? "gray" : "white",
  fillOpacity: 0.1
}, ownerState.axisHighlight === "line" && {
  strokeDasharray: "5 2",
  stroke: theme.palette.mode === "light" ? "#000000" : "#ffffff"
}));
function ChartsAxisHighlight(props) {
  const {
    x: xAxisHighlight,
    y: yAxisHighlight
  } = props;
  const {
    xAxisIds,
    xAxis,
    yAxisIds,
    yAxis
  } = React9.useContext(CartesianContext);
  const classes = useUtilityClasses3();
  const USED_X_AXIS_ID = xAxisIds[0];
  const USED_Y_AXIS_ID = yAxisIds[0];
  const xScale = xAxis[USED_X_AXIS_ID].scale;
  const yScale = yAxis[USED_Y_AXIS_ID].scale;
  const {
    axis
  } = React9.useContext(InteractionContext);
  const getXPosition = getValueToPositionMapper(xScale);
  const getYPosition = getValueToPositionMapper(yScale);
  return (0, import_jsx_runtime8.jsxs)(React9.Fragment, {
    children: [xAxisHighlight === "band" && axis.x !== null && isBandScale(xScale) && (0, import_jsx_runtime8.jsx)(ChartsAxisHighlightPath, {
      d: `M ${xScale(axis.x.value) - (xScale.step() - xScale.bandwidth()) / 2} ${yScale.range()[0]} l ${xScale.step()} 0 l 0 ${yScale.range()[1] - yScale.range()[0]} l ${-xScale.step()} 0 Z`,
      className: classes.root,
      ownerState: {
        axisHighlight: "band"
      }
    }), yAxisHighlight === "band" && axis.y !== null && isBandScale(yScale) && (0, import_jsx_runtime8.jsx)(ChartsAxisHighlightPath, {
      d: `M ${xScale.range()[0]} ${yScale(axis.y.value) - (yScale.step() - yScale.bandwidth()) / 2} l 0 ${yScale.step()} l ${xScale.range()[1] - xScale.range()[0]} 0 l 0 ${-yScale.step()} Z`,
      className: classes.root,
      ownerState: {
        axisHighlight: "band"
      }
    }), xAxisHighlight === "line" && axis.x !== null && (0, import_jsx_runtime8.jsx)(ChartsAxisHighlightPath, {
      d: `M ${getXPosition(axis.x.value)} ${yScale.range()[0]} L ${getXPosition(axis.x.value)} ${yScale.range()[1]}`,
      className: classes.root,
      ownerState: {
        axisHighlight: "line"
      }
    }), yAxisHighlight === "line" && axis.y !== null && (0, import_jsx_runtime8.jsx)(ChartsAxisHighlightPath, {
      d: `M ${xScale.range()[0]} ${getYPosition(axis.y.value)} L ${xScale.range()[1]} ${getYPosition(axis.y.value)}`,
      className: classes.root,
      ownerState: {
        axisHighlight: "line"
      }
    })]
  });
}
true ? ChartsAxisHighlight.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  x: import_prop_types8.default.oneOf(["band", "line", "none"]),
  y: import_prop_types8.default.oneOf(["band", "line", "none"])
} : void 0;

// node_modules/@mui/x-charts/esm/ResponsiveChartContainer/ResponsiveChartContainer.js
init_extends();
init_objectWithoutPropertiesLoose();
var React11 = __toESM(require_react());
var import_prop_types9 = __toESM(require_prop_types());
init_styles();

// node_modules/@mui/x-charts/esm/ResponsiveChartContainer/useChartContainerDimensions.js
var React10 = __toESM(require_react());
init_useEnhancedEffect();
init_ownerWindow();
var useChartContainerDimensions = (inWidth, inHeight) => {
  const rootRef = React10.useRef(null);
  const displayError = React10.useRef(false);
  const [width, setWidth] = React10.useState(0);
  const [height, setHeight] = React10.useState(0);
  const computeSize = React10.useCallback(() => {
    const mainEl = rootRef == null ? void 0 : rootRef.current;
    if (!mainEl) {
      return;
    }
    const win = ownerWindow(mainEl);
    const computedStyle = win.getComputedStyle(mainEl);
    const newHeight = Math.floor(parseFloat(computedStyle.height)) || 0;
    const newWidth = Math.floor(parseFloat(computedStyle.width)) || 0;
    setWidth(newWidth);
    setHeight(newHeight);
  }, []);
  React10.useEffect(() => {
    displayError.current = true;
  }, []);
  useEnhancedEffect_default(() => {
    if (inWidth !== void 0 && inHeight !== void 0) {
      return () => {
      };
    }
    computeSize();
    const elementToObserve = rootRef.current;
    if (typeof ResizeObserver === "undefined") {
      return () => {
      };
    }
    let animationFrame;
    const observer = new ResizeObserver(() => {
      animationFrame = requestAnimationFrame(() => {
        computeSize();
      });
    });
    if (elementToObserve) {
      observer.observe(elementToObserve);
    }
    return () => {
      if (animationFrame) {
        window.cancelAnimationFrame(animationFrame);
      }
      if (elementToObserve) {
        observer.unobserve(elementToObserve);
      }
    };
  }, [computeSize, inHeight, inWidth]);
  if (true) {
    if (displayError.current && inWidth === void 0 && width === 0) {
      console.error(`MUI X Charts: ChartContainer does not have \`width\` prop, and its container has no \`width\` defined.`);
      displayError.current = false;
    }
    if (displayError.current && inHeight === void 0 && height === 0) {
      console.error(`MUI X Charts: ChartContainer does not have \`height\` prop, and its container has no \`height\` defined.`);
      displayError.current = false;
    }
  }
  return [rootRef, inWidth ?? width, inHeight ?? height];
};

// node_modules/@mui/x-charts/esm/ResponsiveChartContainer/ResponsiveChartContainer.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime());
var _excluded3 = ["width", "height"];
var ResizableContainer = styled_default("div", {
  name: "MuiResponsiveChart",
  slot: "Container"
})(({
  ownerState
}) => ({
  width: ownerState.width ?? "100%",
  height: ownerState.height ?? "100%",
  display: "flex",
  position: "relative",
  flexGrow: 1,
  flexDirection: "column",
  alignItems: "center",
  justifyContent: "center",
  overflow: "hidden",
  "&>svg": {
    width: "100%",
    height: "100%"
  }
}));
var ResponsiveChartContainer = React11.forwardRef(function ResponsiveChartContainer2(props, ref) {
  const {
    width: inWidth,
    height: inHeight
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded3);
  const [containerRef, width, height] = useChartContainerDimensions(inWidth, inHeight);
  return (0, import_jsx_runtime9.jsx)(ResizableContainer, {
    ref: containerRef,
    ownerState: {
      width: inWidth,
      height: inHeight
    },
    children: width && height ? (0, import_jsx_runtime9.jsx)(ChartContainer, _extends({}, other, {
      width,
      height,
      ref
    })) : null
  });
});
true ? ResponsiveChartContainer.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  children: import_prop_types9.default.node,
  className: import_prop_types9.default.string,
  /**
   * Color palette used to colorize multiple series.
   * @default blueberryTwilightPalette
   */
  colors: import_prop_types9.default.oneOfType([import_prop_types9.default.arrayOf(import_prop_types9.default.string), import_prop_types9.default.func]),
  /**
   * An array of objects that can be used to populate series and axes data using their `dataKey` property.
   */
  dataset: import_prop_types9.default.arrayOf(import_prop_types9.default.object),
  desc: import_prop_types9.default.string,
  /**
   * If `true`, the charts will not listen to the mouse move event.
   * It might break interactive features, but will improve performance.
   * @default false
   */
  disableAxisListener: import_prop_types9.default.bool,
  /**
   * The height of the chart in px. If not defined, it takes the height of the parent element.
   */
  height: import_prop_types9.default.number,
  /**
   * The item currently highlighted. Turns highlighting into a controlled prop.
   */
  highlightedItem: import_prop_types9.default.shape({
    dataIndex: import_prop_types9.default.number,
    seriesId: import_prop_types9.default.oneOfType([import_prop_types9.default.number, import_prop_types9.default.string])
  }),
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   * Accepts an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   * @default object Depends on the charts type.
   */
  margin: import_prop_types9.default.shape({
    bottom: import_prop_types9.default.number,
    left: import_prop_types9.default.number,
    right: import_prop_types9.default.number,
    top: import_prop_types9.default.number
  }),
  /**
   * The callback fired when the highlighted item changes.
   *
   * @param {HighlightItemData | null} highlightedItem  The newly highlighted item.
   */
  onHighlightChange: import_prop_types9.default.func,
  /**
   * The array of series to display.
   * Each type of series has its own specificity.
   * Please refer to the appropriate docs page to learn more about it.
   */
  series: import_prop_types9.default.arrayOf(import_prop_types9.default.object).isRequired,
  sx: import_prop_types9.default.oneOfType([import_prop_types9.default.arrayOf(import_prop_types9.default.oneOfType([import_prop_types9.default.func, import_prop_types9.default.object, import_prop_types9.default.bool])), import_prop_types9.default.func, import_prop_types9.default.object]),
  title: import_prop_types9.default.string,
  viewBox: import_prop_types9.default.shape({
    height: import_prop_types9.default.number,
    width: import_prop_types9.default.number,
    x: import_prop_types9.default.number,
    y: import_prop_types9.default.number
  }),
  /**
   * The width of the chart in px. If not defined, it takes the width of the parent element.
   */
  width: import_prop_types9.default.number,
  /**
   * The configuration of the x-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  xAxis: import_prop_types9.default.arrayOf(import_prop_types9.default.shape({
    axisId: import_prop_types9.default.oneOfType([import_prop_types9.default.number, import_prop_types9.default.string]),
    classes: import_prop_types9.default.object,
    colorMap: import_prop_types9.default.oneOfType([import_prop_types9.default.shape({
      colors: import_prop_types9.default.arrayOf(import_prop_types9.default.string).isRequired,
      type: import_prop_types9.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types9.default.string,
      values: import_prop_types9.default.arrayOf(import_prop_types9.default.oneOfType([import_prop_types9.default.instanceOf(Date), import_prop_types9.default.number, import_prop_types9.default.string]).isRequired)
    }), import_prop_types9.default.shape({
      color: import_prop_types9.default.oneOfType([import_prop_types9.default.arrayOf(import_prop_types9.default.string.isRequired), import_prop_types9.default.func]).isRequired,
      max: import_prop_types9.default.oneOfType([import_prop_types9.default.instanceOf(Date), import_prop_types9.default.number]),
      min: import_prop_types9.default.oneOfType([import_prop_types9.default.instanceOf(Date), import_prop_types9.default.number]),
      type: import_prop_types9.default.oneOf(["continuous"]).isRequired
    }), import_prop_types9.default.shape({
      colors: import_prop_types9.default.arrayOf(import_prop_types9.default.string).isRequired,
      thresholds: import_prop_types9.default.arrayOf(import_prop_types9.default.oneOfType([import_prop_types9.default.instanceOf(Date), import_prop_types9.default.number]).isRequired).isRequired,
      type: import_prop_types9.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types9.default.array,
    dataKey: import_prop_types9.default.string,
    disableLine: import_prop_types9.default.bool,
    disableTicks: import_prop_types9.default.bool,
    fill: import_prop_types9.default.string,
    hideTooltip: import_prop_types9.default.bool,
    id: import_prop_types9.default.oneOfType([import_prop_types9.default.number, import_prop_types9.default.string]),
    label: import_prop_types9.default.string,
    labelFontSize: import_prop_types9.default.number,
    labelStyle: import_prop_types9.default.object,
    max: import_prop_types9.default.oneOfType([import_prop_types9.default.instanceOf(Date), import_prop_types9.default.number]),
    min: import_prop_types9.default.oneOfType([import_prop_types9.default.instanceOf(Date), import_prop_types9.default.number]),
    position: import_prop_types9.default.oneOf(["bottom", "left", "right", "top"]),
    reverse: import_prop_types9.default.bool,
    scaleType: import_prop_types9.default.oneOf(["band", "linear", "log", "point", "pow", "sqrt", "time", "utc"]),
    slotProps: import_prop_types9.default.object,
    slots: import_prop_types9.default.object,
    stroke: import_prop_types9.default.string,
    tickFontSize: import_prop_types9.default.number,
    tickInterval: import_prop_types9.default.oneOfType([import_prop_types9.default.oneOf(["auto"]), import_prop_types9.default.array, import_prop_types9.default.func]),
    tickLabelInterval: import_prop_types9.default.oneOfType([import_prop_types9.default.oneOf(["auto"]), import_prop_types9.default.func]),
    tickLabelPlacement: import_prop_types9.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types9.default.object,
    tickMaxStep: import_prop_types9.default.number,
    tickMinStep: import_prop_types9.default.number,
    tickNumber: import_prop_types9.default.number,
    tickPlacement: import_prop_types9.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types9.default.number,
    valueFormatter: import_prop_types9.default.func
  })),
  /**
   * The configuration of the y-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  yAxis: import_prop_types9.default.arrayOf(import_prop_types9.default.shape({
    axisId: import_prop_types9.default.oneOfType([import_prop_types9.default.number, import_prop_types9.default.string]),
    classes: import_prop_types9.default.object,
    colorMap: import_prop_types9.default.oneOfType([import_prop_types9.default.shape({
      colors: import_prop_types9.default.arrayOf(import_prop_types9.default.string).isRequired,
      type: import_prop_types9.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types9.default.string,
      values: import_prop_types9.default.arrayOf(import_prop_types9.default.oneOfType([import_prop_types9.default.instanceOf(Date), import_prop_types9.default.number, import_prop_types9.default.string]).isRequired)
    }), import_prop_types9.default.shape({
      color: import_prop_types9.default.oneOfType([import_prop_types9.default.arrayOf(import_prop_types9.default.string.isRequired), import_prop_types9.default.func]).isRequired,
      max: import_prop_types9.default.oneOfType([import_prop_types9.default.instanceOf(Date), import_prop_types9.default.number]),
      min: import_prop_types9.default.oneOfType([import_prop_types9.default.instanceOf(Date), import_prop_types9.default.number]),
      type: import_prop_types9.default.oneOf(["continuous"]).isRequired
    }), import_prop_types9.default.shape({
      colors: import_prop_types9.default.arrayOf(import_prop_types9.default.string).isRequired,
      thresholds: import_prop_types9.default.arrayOf(import_prop_types9.default.oneOfType([import_prop_types9.default.instanceOf(Date), import_prop_types9.default.number]).isRequired).isRequired,
      type: import_prop_types9.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types9.default.array,
    dataKey: import_prop_types9.default.string,
    disableLine: import_prop_types9.default.bool,
    disableTicks: import_prop_types9.default.bool,
    fill: import_prop_types9.default.string,
    hideTooltip: import_prop_types9.default.bool,
    id: import_prop_types9.default.oneOfType([import_prop_types9.default.number, import_prop_types9.default.string]),
    label: import_prop_types9.default.string,
    labelFontSize: import_prop_types9.default.number,
    labelStyle: import_prop_types9.default.object,
    max: import_prop_types9.default.oneOfType([import_prop_types9.default.instanceOf(Date), import_prop_types9.default.number]),
    min: import_prop_types9.default.oneOfType([import_prop_types9.default.instanceOf(Date), import_prop_types9.default.number]),
    position: import_prop_types9.default.oneOf(["bottom", "left", "right", "top"]),
    reverse: import_prop_types9.default.bool,
    scaleType: import_prop_types9.default.oneOf(["band", "linear", "log", "point", "pow", "sqrt", "time", "utc"]),
    slotProps: import_prop_types9.default.object,
    slots: import_prop_types9.default.object,
    stroke: import_prop_types9.default.string,
    tickFontSize: import_prop_types9.default.number,
    tickInterval: import_prop_types9.default.oneOfType([import_prop_types9.default.oneOf(["auto"]), import_prop_types9.default.array, import_prop_types9.default.func]),
    tickLabelInterval: import_prop_types9.default.oneOfType([import_prop_types9.default.oneOf(["auto"]), import_prop_types9.default.func]),
    tickLabelPlacement: import_prop_types9.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types9.default.object,
    tickMaxStep: import_prop_types9.default.number,
    tickMinStep: import_prop_types9.default.number,
    tickNumber: import_prop_types9.default.number,
    tickPlacement: import_prop_types9.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types9.default.number,
    valueFormatter: import_prop_types9.default.func
  }))
} : void 0;

// node_modules/@mui/x-charts/esm/hooks/useInteractionItemProps.js
var React12 = __toESM(require_react());
var useInteractionItemProps = (skip) => {
  const {
    dispatch: dispatchInteraction
  } = React12.useContext(InteractionContext);
  const {
    setHighlighted,
    clearHighlighted
  } = React12.useContext(HighlightedContext);
  if (skip) {
    return () => ({});
  }
  const getInteractionItemProps = (data) => {
    const onMouseEnter = () => {
      dispatchInteraction({
        type: "enterItem",
        data
      });
      setHighlighted({
        seriesId: data.seriesId,
        dataIndex: data.dataIndex
      });
    };
    const onMouseLeave = () => {
      dispatchInteraction({
        type: "leaveItem",
        data
      });
      clearHighlighted();
    };
    return {
      onMouseEnter,
      onMouseLeave
    };
  };
  return getInteractionItemProps;
};

// node_modules/@mui/x-charts/esm/ChartsOverlay/ChartsOverlay.js
init_extends();
var React15 = __toESM(require_react());

// node_modules/@mui/x-charts/esm/ChartsOverlay/ChartsLoadingOverlay.js
init_objectWithoutPropertiesLoose();
init_extends();
var React13 = __toESM(require_react());
init_styles();
var import_jsx_runtime10 = __toESM(require_jsx_runtime());
var _excluded4 = ["message"];
var StyledText = styled_default("text")(({
  theme
}) => _extends({}, theme.typography.body2, {
  stroke: "none",
  fill: theme.palette.text.primary,
  shapeRendering: "crispEdges",
  textAnchor: "middle",
  dominantBaseline: "middle"
}));
function ChartsLoadingOverlay(props) {
  const {
    message
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded4);
  const {
    top,
    left,
    height,
    width
  } = useDrawingArea();
  return (0, import_jsx_runtime10.jsx)(StyledText, _extends({
    x: left + width / 2,
    y: top + height / 2
  }, other, {
    children: message ?? "Loading data…"
  }));
}

// node_modules/@mui/x-charts/esm/ChartsOverlay/ChartsNoDataOverlay.js
init_objectWithoutPropertiesLoose();
init_extends();
var React14 = __toESM(require_react());
init_styles();
var import_jsx_runtime11 = __toESM(require_jsx_runtime());
var _excluded5 = ["message"];
var StyledText2 = styled_default("text")(({
  theme
}) => _extends({}, theme.typography.body2, {
  stroke: "none",
  fill: theme.palette.text.primary,
  shapeRendering: "crispEdges",
  textAnchor: "middle",
  dominantBaseline: "middle"
}));
function ChartsNoDataOverlay(props) {
  const {
    message
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded5);
  const {
    top,
    left,
    height,
    width
  } = useDrawingArea();
  return (0, import_jsx_runtime11.jsx)(StyledText2, _extends({
    x: left + width / 2,
    y: top + height / 2
  }, other, {
    children: message ?? "No data to display"
  }));
}

// node_modules/@mui/x-charts/esm/ChartsOverlay/ChartsOverlay.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime());
function useNoData() {
  const seriesPerType = useSeries();
  return Object.values(seriesPerType).every((seriesOfGivenType) => {
    if (!seriesOfGivenType) {
      return true;
    }
    const {
      series,
      seriesOrder
    } = seriesOfGivenType;
    return seriesOrder.every((seriesId) => series[seriesId].data.length === 0);
  });
}
function ChartsOverlay(props) {
  var _a, _b, _c, _d;
  const noData = useNoData();
  if (props.loading) {
    const LoadingOverlay = ((_a = props.slots) == null ? void 0 : _a.loadingOverlay) ?? ChartsLoadingOverlay;
    return (0, import_jsx_runtime12.jsx)(LoadingOverlay, _extends({}, (_b = props.slotProps) == null ? void 0 : _b.loadingOverlay));
  }
  if (noData) {
    const NoDataOverlay = ((_c = props.slots) == null ? void 0 : _c.noDataOverlay) ?? ChartsNoDataOverlay;
    return (0, import_jsx_runtime12.jsx)(NoDataOverlay, _extends({}, (_d = props.slotProps) == null ? void 0 : _d.noDataOverlay));
  }
  return null;
}

export {
  getChartsTooltipUtilityClass,
  chartsTooltipClasses,
  DefaultChartsItemTooltipContent,
  getColor,
  getColor2,
  getColor3,
  ChartsItemTooltipContent,
  DefaultChartsAxisTooltipContent,
  ChartsAxisTooltipContent,
  ChartsTooltip,
  getSeriesToDisplay,
  getLegendUtilityClass,
  legendClasses,
  ChartsLegendRoot,
  DefaultChartsLegend,
  ChartsLegend,
  getAxisHighlightUtilityClass,
  chartsAxisHighlightClasses,
  ChartsAxisHighlightPath,
  ChartsAxisHighlight,
  useInteractionItemProps,
  useChartContainerDimensions,
  ResponsiveChartContainer,
  ChartsOverlay
};
//# sourceMappingURL=chunk-YVTNHLCV.js.map
