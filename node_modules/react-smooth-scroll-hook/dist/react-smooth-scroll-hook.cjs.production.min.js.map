{"version":3,"file":"react-smooth-scroll-hook.cjs.production.min.js","sources":["../src/utils.ts","../src/useSmoothScroll.tsx","../src/useScrollWatch.ts"],"sourcesContent":["export enum Direction {\n  X = 'x',\n  Y = 'y',\n}\nexport type DirectionType = Direction | 'x' | 'y';\nexport type AttrMapType = {\n  scrollLeftTop: 'scrollLeft' | 'scrollTop';\n  scrollWidthHeight: 'scrollWidth' | 'scrollHeight';\n  clientWidthHeight: 'clientWidth' | 'clientHeight';\n  offsetLeftTop: 'offsetLeft' | 'offsetTop';\n  offsetWidthHeight: 'offsetWidth' | 'offsetHeight';\n  leftTop: 'top' | 'left';\n};\nexport const getAttrMap = (direction: DirectionType) => {\n  return {\n    leftTop: Direction.X === direction ? 'left' : 'top',\n    offsetLeftTop: Direction.X === direction ? 'offsetLeft' : 'offsetTop',\n    offsetWidthHeight:\n      Direction.X === direction ? 'offsetWidth' : 'offsetHeight',\n    scrollLeftTop: Direction.X === direction ? 'scrollLeft' : 'scrollTop',\n    scrollWidthHeight:\n      Direction.X === direction ? 'scrollWidth' : 'scrollHeight',\n    clientWidthHeight:\n      Direction.X === direction ? 'clientWidth' : 'clientHeight',\n  } as AttrMapType;\n};\n\nexport function debounce(cb: Function, delay = 100) {\n  let timer: NodeJS.Timeout;\n  return function(...args: any) {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n    // @ts-ignore\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const _this = this;\n    if (timer) clearTimeout(timer);\n    timer = setTimeout(() => {\n      cb.apply(_this, args);\n    }, delay);\n  };\n}\n\n// judge body or documentElement\nexport const isWindowScrollParent = (elm: HTMLElement) => {\n  return !elm.parentElement || !elm.parentElement.parentElement;\n};\n","import React, { useState } from 'react';\nimport { useEffect } from 'react';\nimport {\n  debounce,\n  getAttrMap,\n  AttrMapType,\n  Direction,\n  DirectionType,\n  isWindowScrollParent,\n} from './utils';\n\nexport type UseSmoothScrollType = {\n  /** the container dom RefObject which use `overflow:scroll`, if scroll whole document, pass `ref = useRef(document.documentElement)` or `useRef(document.body)`. */\n  ref: React.RefObject<HTMLElement>;\n  /** distance per frame, reflects to speed while scrolling */\n  speed?: number;\n  /** scroll direction, you can use 'x` for vertical, 'y` for horizontal */\n  direction?: DirectionType;\n  /** allowable distance beteween nowable state the judgement edge */\n  threshold?: number;\n};\n\n// get the relative distance from destination\nexport const getRelativeDistance = (\n  target: number | string | undefined,\n  parent: HTMLElement,\n  attrMap: AttrMapType\n) => {\n  if (typeof target === 'number') return target;\n  if (typeof target === 'string') {\n    const elm = document.querySelector(target);\n    if (!elm) {\n      console.warn('Please pass correct selector string for scrollTo()!');\n      return 0;\n    }\n    let dis = 0;\n\n    // if parent is document.documentElement or document.body\n    if (isWindowScrollParent(parent)) {\n      dis = elm.getBoundingClientRect()[attrMap.leftTop];\n    } else {\n      dis =\n        elm.getBoundingClientRect()[attrMap.leftTop] -\n        parent.getBoundingClientRect()[attrMap.leftTop];\n    }\n\n    return dis;\n  }\n  return 0;\n};\n\nexport const useSmoothScroll = ({\n  ref,\n  speed = 100,\n  direction = Direction.Y,\n  threshold = 1,\n}: UseSmoothScrollType) => {\n  const attrMap = getAttrMap(direction);\n\n  const [reachedTop, setReachedTop] = useState(true);\n  const [reachedBottom, setReachedBottom] = useState(true);\n  const [size, setSize] = useState(0);\n\n  const isTopEdge = () => {\n    const elm = ref.current;\n    if (!elm) return false;\n    return elm[attrMap.scrollLeftTop] === 0;\n  };\n\n  const isBottomEdge = () => {\n    const elm = ref.current;\n    if (!elm) return false;\n    return (\n      Math.abs(\n        elm[attrMap.scrollLeftTop] +\n          elm[attrMap.clientWidthHeight] -\n          elm[attrMap.scrollWidthHeight]\n      ) < threshold\n    );\n  };\n\n  const refreshSize = debounce(() => {\n    if (ref.current) {\n      const size = ref.current[attrMap.clientWidthHeight];\n      setSize(size);\n    }\n  });\n\n  const refreshState = debounce((_evt: Event) => {\n    isTopEdge() ? setReachedTop(true) : setReachedTop(false);\n    isBottomEdge() ? setReachedBottom(true) : setReachedBottom(false);\n  });\n\n  const scrollTo = (target?: number | string, offset?: number) => {\n    if (!ref || !ref.current) {\n      console.warn(\n        'Please pass `ref` property for your scroll container! \\n Get more info at https://github.com/ron0115/react-smooth-scroll-hook'\n      );\n      return;\n    }\n    const elm = ref.current;\n    if (!elm) return;\n    if (!target && typeof target !== 'number') {\n      console.warn(\n        'Please pass a valid property for `scrollTo()`! \\n Get more info at https://github.com/ron0115/react-smooth-scroll-hook'\n      );\n    }\n\n    const initScrollLeftTop = elm[attrMap.scrollLeftTop];\n\n    let distance = getRelativeDistance(target, elm, attrMap);\n\n    // set a offset\n    if (typeof offset === 'number') {\n      distance += offset;\n    }\n\n    let _speed = speed;\n    const cb = () => {\n      refreshState();\n\n      if (distance === 0) return;\n\n      if ((isBottomEdge() && distance > 9) || (distance < 0 && isTopEdge()))\n        return;\n\n      const gone = () =>\n        Math.abs(elm[attrMap.scrollLeftTop] - initScrollLeftTop);\n\n      if (Math.abs(distance) - gone() < _speed) {\n        _speed = Math.abs(distance) - gone();\n      }\n\n      // distance to run every frameï¼Œalways 1/60s\n      elm[attrMap.scrollLeftTop] += _speed * (distance > 0 ? 1 : -1);\n\n      // reach destination, threshold defaults to 1\n      if (Math.abs(gone() - Math.abs(distance)) < threshold) {\n        return;\n      }\n\n      requestAnimationFrame(cb);\n    };\n    requestAnimationFrame(cb);\n  };\n\n  // detect dom changes\n  useEffect(() => {\n    if (!ref.current) return;\n\n    refreshState();\n    refreshSize();\n    const observer = new MutationObserver((mutationsList, _observer) => {\n      // Use traditional 'for loops' for IE 11\n      for (const mutation of mutationsList) {\n        if (\n          mutation.type === 'attributes' &&\n          mutation.target instanceof Element\n        ) {\n          refreshSize();\n        }\n      }\n    });\n    observer.observe(ref.current, {\n      attributes: true,\n    });\n    window.addEventListener('resize', refreshSize);\n    return () => {\n      observer.disconnect();\n      window.removeEventListener('resize', refreshSize);\n    };\n  }, [ref, refreshState, refreshSize]);\n\n  // detect scrollbar changes\n  useEffect(() => {\n    if (!ref.current) return;\n    const elm = ref.current;\n    const observer = new MutationObserver((mutationsList, _observer) => {\n      // Use traditional 'for loops' for IE 11\n      for (const mutation of mutationsList) {\n        if (\n          mutation.type === 'childList' &&\n          mutation.target instanceof Element\n        ) {\n          refreshState();\n        }\n      }\n    });\n    observer.observe(elm, {\n      childList: true,\n      subtree: true,\n    });\n    elm.addEventListener('scroll', refreshState);\n    return () => {\n      observer.disconnect();\n      elm && elm.removeEventListener('scroll', refreshState);\n    };\n  }, [ref, refreshState]);\n\n  return {\n    reachedTop,\n    reachedBottom,\n    containerSize: size,\n    scrollTo,\n    /** @deprecated replace with scrollTo(n * containerSize) */\n    scrollToPage: (page: number) => {\n      scrollTo(page * size);\n    },\n    /** @deprecated */\n    refreshState,\n    /** @deprecated */\n    refreshSize,\n  };\n};\nexport default useSmoothScroll;\n","import { useEffect, useState } from 'react';\nimport {\n  debounce,\n  DirectionType,\n  getAttrMap,\n  isWindowScrollParent,\n} from './utils';\n\nexport type useScrollWathType = {\n  /** the container dom RefObject which use `overflow:scroll`,if scroll whole document, pass `ref = useRef(document.documentElement)` or `useRef(document.body)`. */\n  ref: React.RefObject<HTMLElement>;\n  list: {\n    /** dom id of Element */\n    href: string;\n    /** the scroll position judge preset of each Element */\n    offset?: number;\n  }[];\n  /** global offset for every Element of list */\n  offset?: number;\n  /** scroll axis, x for horizontal, y for vertical */\n  direction?: DirectionType;\n};\n\nexport const getCurIndex = (scrollTop: number, list: number[]) => {\n  const length = list.length;\n  if (!length) return -1;\n\n  for (let i = 0; i < length; i++) {\n    if (scrollTop < list[i]) {\n      return i - 1;\n    }\n  }\n\n  if (scrollTop >= list[length - 1]) {\n    return list.length - 1;\n  }\n\n  return -1;\n};\n\nexport const useScrollWatch = (props: useScrollWathType) => {\n  const { ref, list = [], offset, direction = 'y' } = props;\n\n  const attrMap = getAttrMap(direction);\n\n  const getScrollTop = () => {\n    const elm = ref.current;\n    if (!elm) return 0;\n    return elm[attrMap.scrollLeftTop];\n  };\n\n  const [scrollTop, setScrollTop] = useState(getScrollTop() || 0);\n\n  const getPosList = () => {\n    let posList = list.map(item => {\n      const parent = ref.current;\n      const os = typeof item.offset === 'number' ? item.offset : offset || 0;\n      const elm = document.querySelector(item.href);\n      if (!elm) return Infinity;\n      if (!parent) return Infinity;\n      return isWindowScrollParent(parent)\n        ? elm.getBoundingClientRect()[attrMap.leftTop] -\n            parent.getBoundingClientRect()[attrMap.leftTop] +\n            os\n        : elm.getBoundingClientRect()[attrMap.leftTop] -\n            parent.children[0].getBoundingClientRect()[attrMap.leftTop] +\n            os;\n    });\n    return posList;\n  };\n\n  const refresh = debounce(() => {\n    setScrollTop(getScrollTop());\n    setPosList(getPosList());\n  }, 100);\n\n  const [posList, setPosList] = useState<number[]>([]);\n\n  useEffect(() => {\n    refresh();\n  }, [ref, refresh]);\n\n  const curIndex = getCurIndex(scrollTop, posList);\n\n  useEffect(() => {\n    if (!ref.current) return;\n    const elm = isWindowScrollParent(ref.current) ? window : ref.current;\n    const observer = new window.MutationObserver(refresh);\n    observer.observe(ref.current, {\n      childList: true,\n      subtree: true,\n    });\n    elm.addEventListener('scroll', refresh);\n    return () => {\n      observer.disconnect();\n      elm && elm.removeEventListener('scroll', refresh);\n    };\n  }, [ref, refresh]);\n\n  return {\n    curIndex,\n    scrollTop,\n    curItem: list[curIndex] || {},\n  };\n};\n"],"names":["Direction","getAttrMap","direction","leftTop","X","offsetLeftTop","offsetWidthHeight","scrollLeftTop","scrollWidthHeight","clientWidthHeight","debounce","cb","delay","timer","args","_this","this","clearTimeout","setTimeout","apply","isWindowScrollParent","elm","parentElement","useSmoothScroll","ref","speed","threshold","attrMap","Y","useState","reachedTop","setReachedTop","reachedBottom","setReachedBottom","size","setSize","isTopEdge","current","isBottomEdge","Math","abs","refreshSize","refreshState","_evt","scrollTo","target","offset","console","warn","initScrollLeftTop","distance","parent","document","querySelector","getBoundingClientRect","getRelativeDistance","_speed","requestAnimationFrame","gone","useEffect","observer","MutationObserver","mutationsList","_observer","mutation","type","Element","observe","attributes","window","addEventListener","disconnect","removeEventListener","childList","subtree","containerSize","scrollToPage","page","props","list","getScrollTop","scrollTop","setScrollTop","refresh","setPosList","map","item","os","href","children","Infinity","posList","curIndex","length","i","getCurIndex","curItem"],"mappings":"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"}